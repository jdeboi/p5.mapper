(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["p5.mapper"] = factory();
	else
		root["p5.mapper"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

;// CONCATENATED MODULE: ./src/perspective/numeric.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var numeric = {};

numeric.dim = function dim(x) {
  var y, z;

  if (_typeof(x) === "object") {
    y = x[0];

    if (_typeof(y) === "object") {
      z = y[0];

      if (_typeof(z) === "object") {
        return numeric._dim(x);
      }

      return [x.length, y.length];
    }

    return [x.length];
  }

  return [];
};

numeric._foreach2 = function _foreach2(x, s, k, f) {
  if (k === s.length - 1) {
    return f(x);
  }

  var i,
      n = s[k],
      ret = Array(n);

  for (i = n - 1; i >= 0; i--) {
    ret[i] = _foreach2(x[i], s, k + 1, f);
  }

  return ret;
};

numeric.cloneV = function (x) {
  var _n = x.length;
  var i,
      ret = Array(_n);

  for (i = _n - 1; i !== -1; --i) {
    ret[i] = x[i];
  }

  return ret;
};

numeric.clone = function (x) {
  if (_typeof(x) !== "object") return x;
  var V = numeric.cloneV;
  var s = numeric.dim(x);
  return numeric._foreach2(x, s, 0, V);
};

numeric.diag = function diag(d) {
  var i,
      i1,
      j,
      n = d.length,
      A = Array(n),
      Ai;

  for (i = n - 1; i >= 0; i--) {
    Ai = Array(n);
    i1 = i + 2;

    for (j = n - 1; j >= i1; j -= 2) {
      Ai[j] = 0;
      Ai[j - 1] = 0;
    }

    if (j > i) {
      Ai[j] = 0;
    }

    Ai[i] = d[i];

    for (j = i - 1; j >= 1; j -= 2) {
      Ai[j] = 0;
      Ai[j - 1] = 0;
    }

    if (j === 0) {
      Ai[0] = 0;
    }

    A[i] = Ai;
  }

  return A;
};

numeric.rep = function rep(s, v, k) {
  if (typeof k === "undefined") {
    k = 0;
  }

  var n = s[k],
      ret = Array(n),
      i;

  if (k === s.length - 1) {
    for (i = n - 2; i >= 0; i -= 2) {
      ret[i + 1] = v;
      ret[i] = v;
    }

    if (i === -1) {
      ret[0] = v;
    }

    return ret;
  }

  for (i = n - 1; i >= 0; i--) {
    ret[i] = numeric.rep(s, v, k + 1);
  }

  return ret;
};

numeric.identity = function (n) {
  return numeric.diag(numeric.rep([n], 1));
};

numeric.inv = function inv(a) {
  var s = numeric.dim(a),
      abs = Math.abs,
      m = s[0],
      n = s[1];
  var A = numeric.clone(a),
      Ai,
      Aj;
  var I = numeric.identity(m),
      Ii,
      Ij;
  var i, j, k, x;

  for (j = 0; j < n; ++j) {
    var i0 = -1;
    var v0 = -1;

    for (i = j; i !== m; ++i) {
      k = abs(A[i][j]);

      if (k > v0) {
        i0 = i;
        v0 = k;
      }
    }

    Aj = A[i0];
    A[i0] = A[j];
    A[j] = Aj;
    Ij = I[i0];
    I[i0] = I[j];
    I[j] = Ij;
    x = Aj[j];

    for (k = j; k !== n; ++k) {
      Aj[k] /= x;
    }

    for (k = n - 1; k !== -1; --k) {
      Ij[k] /= x;
    }

    for (i = m - 1; i !== -1; --i) {
      if (i !== j) {
        Ai = A[i];
        Ii = I[i];
        x = Ai[j];

        for (k = j + 1; k !== n; ++k) {
          Ai[k] -= Aj[k] * x;
        }

        for (k = n - 1; k > 0; --k) {
          Ii[k] -= Ij[k] * x;
          --k;
          Ii[k] -= Ij[k] * x;
        }

        if (k === 0) Ii[0] -= Ij[0] * x;
      }
    }
  }

  return I;
};

numeric.dotMMsmall = function dotMMsmall(x, y) {
  var i, j, k, p, q, r, ret, foo, bar, woo, i0;
  p = x.length;
  q = y.length;
  r = y[0].length;
  ret = Array(p);

  for (i = p - 1; i >= 0; i--) {
    foo = Array(r);
    bar = x[i];

    for (k = r - 1; k >= 0; k--) {
      woo = bar[q - 1] * y[q - 1][k];

      for (j = q - 2; j >= 1; j -= 2) {
        i0 = j - 1;
        woo += bar[j] * y[j][k] + bar[i0] * y[i0][k];
      }

      if (j === 0) {
        woo += bar[0] * y[0][k];
      }

      foo[k] = woo;
    }

    ret[i] = foo;
  }

  return ret;
};

numeric.dotMV = function dotMV(x, y) {
  var p = x.length,
      i;
  var ret = Array(p),
      dotVV = numeric.dotVV;

  for (i = p - 1; i >= 0; i--) {
    ret[i] = dotVV(x[i], y);
  }

  return ret;
};

numeric.dotVV = function dotVV(x, y) {
  var i,
      n = x.length,
      i1,
      ret = x[n - 1] * y[n - 1];

  for (i = n - 2; i >= 1; i -= 2) {
    i1 = i - 1;
    ret += x[i] * y[i] + x[i1] * y[i1];
  }

  if (i === 0) {
    ret += x[0] * y[0];
  }

  return ret;
};

numeric.transpose = function transpose(x) {
  var i,
      j,
      m = x.length,
      n = x[0].length,
      ret = Array(n),
      A0,
      A1,
      Bj;

  for (j = 0; j < n; j++) {
    ret[j] = Array(m);
  }

  for (i = m - 1; i >= 1; i -= 2) {
    A1 = x[i];
    A0 = x[i - 1];

    for (j = n - 1; j >= 1; --j) {
      Bj = ret[j];
      Bj[i] = A1[j];
      Bj[i - 1] = A0[j];
      --j;
      Bj = ret[j];
      Bj[i] = A1[j];
      Bj[i - 1] = A0[j];
    }

    if (j === 0) {
      Bj = ret[0];
      Bj[i] = A1[0];
      Bj[i - 1] = A0[0];
    }
  }

  if (i === 0) {
    A0 = x[0];

    for (j = n - 1; j >= 1; --j) {
      ret[j][0] = A0[j];
      --j;
      ret[j][0] = A0[j];
    }

    if (j === 0) {
      ret[0][0] = A0[0];
    }
  }

  return ret;
};

/* harmony default export */ const perspective_numeric = (numeric);
;// CONCATENATED MODULE: ./src/perspective/PerspT.js


function round(num) {
  return Math.round(num * 10000000000) / 10000000000;
}

function getNormalizationCoefficients(srcPts, dstPts, isInverse) {
  if (isInverse) {
    var tmp = dstPts;
    dstPts = srcPts;
    srcPts = tmp;
  }

  var r1 = [srcPts[0], srcPts[1], 1, 0, 0, 0, -1 * dstPts[0] * srcPts[0], -1 * dstPts[0] * srcPts[1]];
  var r2 = [0, 0, 0, srcPts[0], srcPts[1], 1, -1 * dstPts[1] * srcPts[0], -1 * dstPts[1] * srcPts[1]];
  var r3 = [srcPts[2], srcPts[3], 1, 0, 0, 0, -1 * dstPts[2] * srcPts[2], -1 * dstPts[2] * srcPts[3]];
  var r4 = [0, 0, 0, srcPts[2], srcPts[3], 1, -1 * dstPts[3] * srcPts[2], -1 * dstPts[3] * srcPts[3]];
  var r5 = [srcPts[4], srcPts[5], 1, 0, 0, 0, -1 * dstPts[4] * srcPts[4], -1 * dstPts[4] * srcPts[5]];
  var r6 = [0, 0, 0, srcPts[4], srcPts[5], 1, -1 * dstPts[5] * srcPts[4], -1 * dstPts[5] * srcPts[5]];
  var r7 = [srcPts[6], srcPts[7], 1, 0, 0, 0, -1 * dstPts[6] * srcPts[6], -1 * dstPts[6] * srcPts[7]];
  var r8 = [0, 0, 0, srcPts[6], srcPts[7], 1, -1 * dstPts[7] * srcPts[6], -1 * dstPts[7] * srcPts[7]];
  var matA = [r1, r2, r3, r4, r5, r6, r7, r8];
  var matB = dstPts;
  var matC;

  try {
    matC = perspective_numeric.inv(perspective_numeric.dotMMsmall(perspective_numeric.transpose(matA), matA));
  } catch (e) {
    console.log(e);
    return [1, 0, 0, 0, 1, 0, 0, 0];
  }

  var matD = perspective_numeric.dotMMsmall(matC, perspective_numeric.transpose(matA));
  var matX = perspective_numeric.dotMV(matD, matB);

  for (var i = 0; i < matX.length; i++) {
    matX[i] = round(matX[i]);
  }

  matX[8] = 1;
  return matX;
}

function PerspT(srcPts, dstPts) {
  if (typeof window !== 'undefined' && window === this || this === undefined) {
    return new PerspT(srcPts, dstPts);
  }

  this.srcPts = srcPts;
  this.dstPts = dstPts;
  this.coeffs = getNormalizationCoefficients(this.srcPts, this.dstPts, false);
  this.coeffsInv = getNormalizationCoefficients(this.srcPts, this.dstPts, true);
  return this;
}

PerspT.prototype = {
  transform: function transform(x, y) {
    var coordinates = [];
    coordinates[0] = (this.coeffs[0] * x + this.coeffs[1] * y + this.coeffs[2]) / (this.coeffs[6] * x + this.coeffs[7] * y + 1);
    coordinates[1] = (this.coeffs[3] * x + this.coeffs[4] * y + this.coeffs[5]) / (this.coeffs[6] * x + this.coeffs[7] * y + 1);
    return coordinates;
  },
  transformInverse: function transformInverse(x, y) {
    var coordinates = [];
    coordinates[0] = (this.coeffsInv[0] * x + this.coeffsInv[1] * y + this.coeffsInv[2]) / (this.coeffsInv[6] * x + this.coeffsInv[7] * y + 1);
    coordinates[1] = (this.coeffsInv[3] * x + this.coeffsInv[4] * y + this.coeffsInv[5]) / (this.coeffsInv[6] * x + this.coeffsInv[7] * y + 1);
    return coordinates;
  }
};
/* harmony default export */ const perspective_PerspT = (PerspT);
;// CONCATENATED MODULE: ./src/surfaces/MovePoint.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MovePoint = /*#__PURE__*/function () {
  function MovePoint(parent, x, y, pInst) {
    _classCallCheck(this, MovePoint);

    this.pInst = pInst;
    this.x = x;
    this.type = "CPOINT";
    this.y = y;
    this.r = 8;
    this.isControlPoint = false;
    this.parent = parent;
    this.xStartDrag = this.x;
    this.yStartDrag = this.y;
    this.clickX = 0;
    this.clickY = 0;
    this.col = this.pInst.color(0, 255, 255);
  }

  _createClass(MovePoint, [{
    key: "isMouseOver",
    value: function isMouseOver() {
      var mx = this.pInst.mouseX;
      var my = this.pInst.mouseY; // developed with p5.js 1.4 when WEBGL mode had a different coordinate system
      // (center was origin in WEBGL mode?)
      // updated for p5.js 1.9

      if (true) {
        mx -= this.pInst.width / 2;
        my -= this.pInst.height / 2;
      }

      var d = this.pInst.dist(mx, my, this.x + this.parent.x, this.y + this.parent.y);
      return d < this.r;
    }
  }, {
    key: "set",
    value: function set(point) {
      this.x = point.x;
      this.y = point.y;
    }
  }, {
    key: "startDrag",
    value: function startDrag() {
      this.xStartDrag = this.x;
      this.yStartDrag = this.y;
      this.clickX = this.pInst.mouseX;
      this.clickY = this.pInst.mouseY;
    }
  }, {
    key: "moveToMouse",
    value: function moveToMouse() {
      this.x = this.pInst.mouseX - this.pInst.width / 2;
      this.y = this.pInst.mouseY - this.pInst.height / 2;
    }
  }, {
    key: "moveTo",
    value: function moveTo() {
      this.x = this.xStartDrag + this.pInst.mouseX - this.clickX;
      this.y = this.yStartDrag + this.pInst.mouseY - this.clickY;
    }
  }, {
    key: "setControlPoint",
    value: function setControlPoint(cp) {
      this.isControlPoint = cp;
    }
  }, {
    key: "interpolateBetween",
    value: function interpolateBetween(start, end, f) {
      this.x = start.x + (end.x - start.x) * f;
      this.y = start.y + (end.y - start.y) * f;
    }
  }, {
    key: "display",
    value: function display() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.col;

      if (this.pInst.isMovingPoints()) {
        var c = col;

        if (this.isMouseOver()) {
          c = this.pInst.color(255);
        }

        var isLogo = false;

        if (isLogo) {
          c = this.pInst.color(255);
          this.r = 20;
        }

        this.pInst.push();
        this.pInst.translate(0, 0, 5);
        this.pInst.stroke(c);
        this.pInst.strokeWeight(2);
        this.pInst.noFill();
        this.pInst.ellipse(this.x, this.y, this.r * 2);
        this.pInst.fill(c);
        this.pInst.ellipse(this.x, this.y, this.r);
        this.pInst.pop();
      }
    }
  }]);

  return MovePoint;
}();

/* harmony default export */ const surfaces_MovePoint = (MovePoint);
;// CONCATENATED MODULE: ./src/surfaces/MeshPoint.js
function MeshPoint_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { MeshPoint_typeof = function _typeof(obj) { return typeof obj; }; } else { MeshPoint_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return MeshPoint_typeof(obj); }

function MeshPoint_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MeshPoint_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function MeshPoint_createClass(Constructor, protoProps, staticProps) { if (protoProps) MeshPoint_defineProperties(Constructor.prototype, protoProps); if (staticProps) MeshPoint_defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (MeshPoint_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MeshPoint = /*#__PURE__*/function (_MovePoint) {
  _inherits(MeshPoint, _MovePoint);

  var _super = _createSuper(MeshPoint);

  function MeshPoint(parent, x, y, u, v, pInst) {
    var _this;

    MeshPoint_classCallCheck(this, MeshPoint);

    _this = _super.call(this, parent, x, y, pInst);
    _this.u = u;
    _this.v = v;
    return _this;
  }

  MeshPoint_createClass(MeshPoint, [{
    key: "set",
    value: function set(point) {
      _get(_getPrototypeOf(MeshPoint.prototype), "set", this).call(this, point);

      this.u = point.u;
      this.v = point.v;
    }
  }, {
    key: "moveTo",
    value: function moveTo() {
      _get(_getPrototypeOf(MeshPoint.prototype), "moveTo", this).call(this);

      this.parent.calculateMesh();
    }
    /**
     * This creates a new MeshPoint with (u,v) = (0,0) and does
     * not modify the current MeshPoint. Its used to generate 
     * temporary points for the interpolation.
     */

  }, {
    key: "interpolateTo",
    value: function interpolateTo(p, f) {
      var nX = this.x + (p.x - this.x) * f;
      var nY = this.y + (p.y - this.y) * f;
      return new MeshPoint(this.parent, nX, nY, 0, 0, this.pInst);
    }
  }]);

  return MeshPoint;
}(surfaces_MovePoint);

/* harmony default export */ const surfaces_MeshPoint = (MeshPoint);
;// CONCATENATED MODULE: ./src/surfaces/Draggable.js
function Draggable_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Draggable_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Draggable_createClass(Constructor, protoProps, staticProps) { if (protoProps) Draggable_defineProperties(Constructor.prototype, protoProps); if (staticProps) Draggable_defineProperties(Constructor, staticProps); return Constructor; }

var Draggable = /*#__PURE__*/function () {
  function Draggable(pInst) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    Draggable_classCallCheck(this, Draggable);

    this.pInst = pInst;
    this.x = x;
    this.y = y;
    this.clickX = 0;
    this.clickY = 0;
    this.xStartDrag = this.x;
    this.yStartDrag = this.y;
  }

  Draggable_createClass(Draggable, [{
    key: "startDrag",
    value: function startDrag() {
      this.xStartDrag = this.x;
      this.yStartDrag = this.y;
      this.clickX = this.pInst.mouseX;
      this.clickY = this.pInst.mouseY;
    }
  }, {
    key: "moveTo",
    value: function moveTo() {
      this.x = this.xStartDrag + this.pInst.mouseX - this.clickX;
      this.y = this.yStartDrag + this.pInst.mouseY - this.clickY;
    }
  }]);

  return Draggable;
}();

/* harmony default export */ const surfaces_Draggable = (Draggable);
;// CONCATENATED MODULE: ./src/helpers/helpers.js
function inside(point, polyon, offset) {
  // ray-casting algorithm based on
  // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html
  var x = point.x,
      y = point.y;
  var inside = false;

  for (var i = 0, j = polyon.length - 1; i < polyon.length; j = i++) {
    var xi = polyon[i].x + offset.x,
        yi = polyon[i].y + offset.y;
    var xj = polyon[j].x + offset.x,
        yj = polyon[j].y + offset.y;
    var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }

  return inside;
}
function getRandomizedColor(id, type, p5) {
  var shapeOffset = type ? type[0].charCodeAt(0) : 2;
  var offset = (1 + id) * 88 + shapeOffset * 80; // a kind of wack hash function (?) for randomized color
  // based on parent (so all 4 control points are same color)

  p5.colorMode(p5.HSB, 255);
  var col = p5.color(offset % 255, 255, 255);
  p5.colorMode(p5.RGB, 255);
  return col;
}
function getPercent(p5) {
  var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  seconds = p5.constrain(seconds, 0.1, 100); // 60 frames / second

  var per = p5.frameCount / (60 * seconds) % 1; // console.log(frameCount / (60*seconds), per)

  return per;
}
function getPercentWave(p5) {
  var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  seconds = p5.constrain(seconds, 0.01, 100);
  var per = 0.5 + 0.5 * p5.sin(p5.frameCount / (60 * seconds) * 2 * p5.PI + offset);
  return per;
}
;// CONCATENATED MODULE: ./src/surfaces/Surface.js
function Surface_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Surface_typeof = function _typeof(obj) { return typeof obj; }; } else { Surface_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Surface_typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function Surface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Surface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Surface_createClass(Constructor, protoProps, staticProps) { if (protoProps) Surface_defineProperties(Constructor.prototype, protoProps); if (staticProps) Surface_defineProperties(Constructor, staticProps); return Constructor; }

function Surface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Surface_setPrototypeOf(subClass, superClass); }

function Surface_setPrototypeOf(o, p) { Surface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Surface_setPrototypeOf(o, p); }

function Surface_createSuper(Derived) { var hasNativeReflectConstruct = Surface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Surface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Surface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Surface_possibleConstructorReturn(this, result); }; }

function Surface_possibleConstructorReturn(self, call) { if (call && (Surface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Surface_assertThisInitialized(self); }

function Surface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Surface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function Surface_getPrototypeOf(o) { Surface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Surface_getPrototypeOf(o); }




var Surface = /*#__PURE__*/function (_Draggable) {
  Surface_inherits(Surface, _Draggable);

  var _super = Surface_createSuper(Surface);

  // since there's a limit on WEBGL context
  function Surface(id, w, h, res, type, buffer, pInst) {
    var _this;

    Surface_classCallCheck(this, Surface);

    _this = _super.call(this, pInst, 0, 0); // https://github.com/processing/p5.js/issues/3736
    // let g = p5.Graphics.call(this, w, h, WEBGL, pInst);
    // g.drawingContext.disable(g.drawingContext.DEPTH_TEST);
    // TODO - think about size of surface...

    _this.width = _this.pInst.constrain(w, 0, _this.pInst.width);
    _this.height = _this.pInst.constrain(h, 0, _this.pInst.height);
    _this.id = id;
    _this.res = Math.floor(res);
    _this.type = type;
    _this.controlPointColor = getRandomizedColor(_this.id, _this.type, _this.pInst);
    _this.buffer = buffer;
    return _this;
  }

  Surface_createClass(Surface, [{
    key: "getMutedControlColor",
    value: function getMutedControlColor() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.controlPointColor;
      return this.pInst.color(this.pInst.red(col), this.pInst.green(col), this.pInst.blue(col), 50);
    }
  }, {
    key: "display",
    value: function display() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pInst.color('black');
      this.buffer.background(col);
      this.displayTexture(this.buffer);
    } // override with geometry specifics

  }, {
    key: "displaySurface",
    value: function displaySurface() {
      var isUV = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var tX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var tY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var tW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var tH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      console.warn("should be overriding with specific geometry...");
    }
  }, {
    key: "displaySketch",
    value: function displaySketch(sketch) {
      var tX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var tY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var texW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var texH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      this.buffer.clear();
      this.buffer.push(); // this.buffer.translate(-this.buffer.width/2, -this.buffer.height/2);
      // draw all textures from top left of surface

      sketch(this.buffer);
      this.buffer.pop();
      this.displayTexture(this.buffer, tX, tY, texW, texH);
    }
  }, {
    key: "displayTexture",
    value: function displayTexture(tex) {
      var tX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var tY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var texW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var texH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      if (!tex || tex.width <= 0 || tex.height <= 0) return;
      if (texW <= 0) texW = tex.width;
      if (texH <= 0) texH = tex.height;
      var tW = tex.width / texW;
      var tH = tex.height / texH;
      this.pInst.push();
      this.pInst.noStroke();
      this.pInst.translate(this.x, this.y);
      this.pInst.textureMode(this.pInst.IMAGE);
      this.pInst.texture(tex);
      this.displaySurface(true, tX, tY, tW, tH);

      if (this.pInst.isCalibratingMapper()) {
        this.displayCalibration();
      }

      this.pInst.pop();
    }
  }, {
    key: "displayCalibration",
    value: function displayCalibration() {
      this.pInst.push(); // TODO -
      // why translate??
      // to do with the way lines overlap in z dimension?
      // translate(0, 0, 3); 

      this.displayOutline();
      this.pInst.pop();
    }
  }, {
    key: "displayOutline",
    value: function displayOutline() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.controlPointColor;
      this.pInst.strokeWeight(3);
      this.pInst.stroke(col);
      this.pInst.fill(this.getMutedControlColor());
      this.displaySurface(false);
    }
  }, {
    key: "isEqual",
    value: function isEqual(json) {
      return json.id === this.id && json.type === this.type;
    }
  }, {
    key: "getBounds",
    value: function getBounds(points) {
      var minX = Math.floor(Math.min.apply(Math, _toConsumableArray(points.map(function (pt) {
        return pt.x;
      }))));
      var minY = Math.floor(Math.min.apply(Math, _toConsumableArray(points.map(function (pt) {
        return pt.y;
      }))));
      var maxX = Math.floor(Math.max.apply(Math, _toConsumableArray(points.map(function (pt) {
        return pt.x;
      }))));
      var maxY = Math.floor(Math.max.apply(Math, _toConsumableArray(points.map(function (pt) {
        return pt.y;
      }))));
      return {
        x: minX,
        y: minY,
        w: maxX - minX,
        h: maxY - minY
      };
    }
  }, {
    key: "setDimensions",
    value: function setDimensions(points) {
      var _this$getBounds = this.getBounds(points),
          w = _this$getBounds.w,
          h = _this$getBounds.h;

      this.width = w;
      this.height = h;
    }
  }]);

  return Surface;
}(surfaces_Draggable); // TRYING OUT A NEW METHOD OF DISPLAYING TEXTURE
// Surface.prototype = Object.create(p5.Graphics.prototype);


/* harmony default export */ const surfaces_Surface = (Surface);
;// CONCATENATED MODULE: ./src/surfaces/CornerPinSurface.js
function CornerPinSurface_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { CornerPinSurface_typeof = function _typeof(obj) { return typeof obj; }; } else { CornerPinSurface_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return CornerPinSurface_typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = CornerPinSurface_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function CornerPinSurface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CornerPinSurface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CornerPinSurface_arrayLikeToArray(o, minLen); }

function CornerPinSurface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function CornerPinSurface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CornerPinSurface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function CornerPinSurface_createClass(Constructor, protoProps, staticProps) { if (protoProps) CornerPinSurface_defineProperties(Constructor.prototype, protoProps); if (staticProps) CornerPinSurface_defineProperties(Constructor, staticProps); return Constructor; }

function CornerPinSurface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) CornerPinSurface_setPrototypeOf(subClass, superClass); }

function CornerPinSurface_setPrototypeOf(o, p) { CornerPinSurface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return CornerPinSurface_setPrototypeOf(o, p); }

function CornerPinSurface_createSuper(Derived) { var hasNativeReflectConstruct = CornerPinSurface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = CornerPinSurface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = CornerPinSurface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return CornerPinSurface_possibleConstructorReturn(this, result); }; }

function CornerPinSurface_possibleConstructorReturn(self, call) { if (call && (CornerPinSurface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return CornerPinSurface_assertThisInitialized(self); }

function CornerPinSurface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function CornerPinSurface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function CornerPinSurface_getPrototypeOf(o) { CornerPinSurface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return CornerPinSurface_getPrototypeOf(o); }




var CornerPinSurface = /*#__PURE__*/function (_Surface) {
  CornerPinSurface_inherits(CornerPinSurface, _Surface);

  var _super = CornerPinSurface_createSuper(CornerPinSurface);

  /**
   * @param id 
   *            Identifier for surface
   * @param w
   *            The surface's width, in pixels
   * @param h
   *            The surface's height, in pixels
   * @param res	
   *            The surface's grid resolution
   * @param type
   *            "QUAD" or "TRI" ...
   * @param pInst
   *            p5 sketch instance
   */
  function CornerPinSurface(id, w, h, res, type, buffer, pInst) {
    var _this;

    CornerPinSurface_classCallCheck(this, CornerPinSurface);

    _this = _super.call(this, id, w, h, res, type, buffer, pInst);
    _this.perspT = null;

    _this.initMesh();

    _this.calculateMesh();

    return _this;
  }

  CornerPinSurface_createClass(CornerPinSurface, [{
    key: "initMesh",
    value: function initMesh() {
      this.mesh = [];

      for (var y = 0; y < this.res; y++) {
        for (var x = 0; x < this.res; x++) {
          var mx = Math.floor(this.pInst.map(x, 0, this.res, 0, this.width));
          var my = Math.floor(this.pInst.map(y, 0, this.res, 0, this.height));
          var u = this.pInst.map(x, 0, this.res, 0, 1);
          var v = this.pInst.map(y, 0, this.res, 0, 1);
          this.mesh[y * this.res + x] = new surfaces_MeshPoint(this, mx, my, u, v, this.pInst);
        }
      }

      this.TL = 0 + 0; // x + y

      this.TR = this.res - 1 + 0;
      this.BL = 0 + (this.res - 1) * this.res;
      this.BR = this.res - 1 + (this.res - 1) * this.res; // make the corners control points

      this.mesh[this.TL].setControlPoint(true);
      this.mesh[this.TR].setControlPoint(true);
      this.mesh[this.BR].setControlPoint(true);
      this.mesh[this.BL].setControlPoint(true);
      this.controlPoints = [];
      this.controlPoints.push(this.mesh[this.TL]);
      this.controlPoints.push(this.mesh[this.TR]);
      this.controlPoints.push(this.mesh[this.BR]);
      this.controlPoints.push(this.mesh[this.BL]);
    } // abstract

  }, {
    key: "calculateMesh",
    value: function calculateMesh() {}
  }, {
    key: "load",
    value: function load(json) {
      var x = json.x,
          y = json.y,
          points = json.points;
      this.x = x;
      this.y = y; // this.setMeshPoints(points);

      var _iterator = _createForOfIteratorHelper(points),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var point = _step.value;
          var mp = this.mesh[point.i];
          mp.x = point.x;
          mp.y = point.y;
          mp.u = point.u;
          mp.v = point.v; // I think the control point is already set... ?
          // mp.setControlPoint(true);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.calculateMesh();
    }
  }, {
    key: "getJson",
    value: function getJson() {
      var sJson = {};
      sJson.id = this.id;
      sJson.res = this.res;
      sJson.x = this.x;
      sJson.y = this.y;
      sJson.w = this.w;
      sJson.h = this.h;
      sJson.type = this.type;
      sJson.points = [];

      for (var i = 0; i < this.mesh.length; i++) {
        if (this.mesh[i].isControlPoint) {
          var point = {};
          point.i = i;
          point.x = this.mesh[i].x;
          point.y = this.mesh[i].y;
          point.u = this.mesh[i].u;
          point.v = this.mesh[i].v;
          sJson.points.push(point);
        }
      } // saveJSON(sJson, `${this.type}_${this.id}.json`)


      return sJson;
    }
  }, {
    key: "getControlPoints",
    value: function getControlPoints() {
      return this.controlPoints;
    }
    /*
    returns PVector
    */
    // getPointOnTransformedPlane(x, y) {
    //     const srcCorners = [0, this.w, 0, this.w, this.h, 0, this.h];
    //     const dstCorners = [
    //         this.mesh[this.TL].x, this.mesh[this.TL].y,
    //         this.mesh[this.TR].x, this.mesh[this.TR].y,
    //         this.mesh[this.BR].x, this.mesh[this.BR].y,
    //         this.mesh[this.BL].x, this.mesh[this.BL].y
    //     ]; // dest
    //     this.perspT = PerspT(srcCorners, dstCorners);
    //     let point = this.perspT.transform(x, y);
    //     let mapped = this.pInst.createVector(point[0], point[1]);
    //     return mapped;
    // }
    // ///////////////
    // MANUAL MESHPOINT MOVE FUNCTIONS
    // added by Daniel Wiedemann
    // to move meshpoints via keyboard for example (in OSX the mouse can not go
    // further then the screen bounds, which is obviously a very unpleasant
    // thing if corner points have to be moved across them)
    // ///////////////

    /**
     * Manually move one of the corners for this surface by some amount. 
     * The "corner" parameter should be either: CornerPinSurface.TL, CornerPinSurface.BL, 
     * CornerPinSurface.TR or CornerPinSurface.BR*
     */
    // moveMeshPointBy(corner, moveX, moveY) {
    //     this.mesh[corner].moveTo(this.mesh[corner].x + moveX, this.mesh[corner].y + moveY);
    // }

  }, {
    key: "selectSurface",
    value: function selectSurface() {
      // if the surface itself is selected
      if (this.isMouseOver()) {
        this.startDrag();
        return this;
      }

      return null;
    }
  }, {
    key: "selectPoints",
    value: function selectPoints() {
      // check if control points are selected
      var cp = this.isMouseOverControlPoints();

      if (cp) {
        cp.startDrag();
        return cp;
      }
    }
  }, {
    key: "isMouseOverControlPoints",
    value: function isMouseOverControlPoints() {
      var _iterator2 = _createForOfIteratorHelper(this.controlPoints),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var cp = _step2.value;

          if (cp.isMouseOver()) {
            return cp;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return false;
    }
    /**
     * Used for mouse selection of surfaces
     * http://www.blackpawn.com/texts/pointinpoly/default.html
     */

  }, {
    key: "isPointInTriangle",
    value: function isPointInTriangle(x, y, a, b, c) {
      var v0 = this.pInst.createVector(c.x - a.x, c.y - a.y);
      var v1 = this.pInst.createVector(b.x - a.x, b.y - a.y);
      var v2 = this.pInst.createVector(x - a.x, y - a.y);
      var dot00 = v0.dot(v0);
      var dot01 = v1.dot(v0);
      var dot02 = v2.dot(v0);
      var dot11 = v1.dot(v1);
      var dot12 = v2.dot(v1); // Compute barycentric coordinates

      var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // Check if point is in triangle

      return u > 0 && v > 0 && u + v < 1;
    }
  }, {
    key: "displayControlPoints",
    value: function displayControlPoints() {
      this.pInst.push();
      this.pInst.translate(this.x, this.y);

      var _iterator3 = _createForOfIteratorHelper(this.controlPoints),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;
          p.display(this.controlPointColor);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.pInst.pop();
    }
    /**
        * This function will give you the position of the mouse in the surface's
        * coordinate system.
        * 
        * @return The transformed mouse position
        */

  }, {
    key: "getTransformedCursor",
    value: function getTransformedCursor(cx, cy) {
      var point = this.perspT(cx - this.x, cy - this.y);
      return this.pInst.createVector(point[0], point[1]);
    }
  }, {
    key: "getTransformedMouse",
    value: function getTransformedMouse() {
      return getTransformedCursor(this.pInst.mouseX, this.pInst.mouseY);
    } // 2d cross product

  }, {
    key: "cross2",
    value: function cross2(x0, y0, x1, y1) {
      return x0 * y1 - y0 * x1;
    }
  }]);

  return CornerPinSurface;
}(surfaces_Surface);

/* harmony default export */ const surfaces_CornerPinSurface = (CornerPinSurface);
;// CONCATENATED MODULE: ./src/surfaces/QuadMap.js
function QuadMap_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { QuadMap_typeof = function _typeof(obj) { return typeof obj; }; } else { QuadMap_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return QuadMap_typeof(obj); }

function QuadMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function QuadMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function QuadMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) QuadMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) QuadMap_defineProperties(Constructor, staticProps); return Constructor; }

function QuadMap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) QuadMap_setPrototypeOf(subClass, superClass); }

function QuadMap_setPrototypeOf(o, p) { QuadMap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return QuadMap_setPrototypeOf(o, p); }

function QuadMap_createSuper(Derived) { var hasNativeReflectConstruct = QuadMap_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = QuadMap_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = QuadMap_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return QuadMap_possibleConstructorReturn(this, result); }; }

function QuadMap_possibleConstructorReturn(self, call) { if (call && (QuadMap_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return QuadMap_assertThisInitialized(self); }

function QuadMap_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function QuadMap_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function QuadMap_getPrototypeOf(o) { QuadMap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return QuadMap_getPrototypeOf(o); }




var QuadMap = /*#__PURE__*/function (_CornerPinSurface) {
  QuadMap_inherits(QuadMap, _CornerPinSurface);

  var _super = QuadMap_createSuper(QuadMap);

  function QuadMap(id, w, h, res, buffer, pInst) {
    var _this;

    QuadMap_classCallCheck(this, QuadMap);

    _this = _super.call(this, id, w, h, res, "QUAD", buffer, pInst); // TODO

    _this.resX = 20;
    _this.resY = 20; // pInst.constrain( pInst.floor(pInst.map(h, 0, 2000, 2, 50)), 2, 50 ); //h / space;

    return _this;
  }
  /**
   * Returns true if the mouse is over this surface, false otherwise.
   */


  QuadMap_createClass(QuadMap, [{
    key: "isMouseOver",
    value: function isMouseOver() {
      var x = this.pInst.mouseX - this.pInst.width / 2;
      var y = this.pInst.mouseY - this.pInst.height / 2;
      if (this.isPointInTriangle(x - this.x, y - this.y, this.mesh[this.TL], this.mesh[this.TR], this.mesh[this.BL]) || this.isPointInTriangle(x - this.x, y - this.y, this.mesh[this.BL], this.mesh[this.TR], this.mesh[this.BR])) return true;
      return false;
    }
  }, {
    key: "calculateMesh",
    value: function calculateMesh() {
      // The float constructor is deprecated, so casting everything to double
      var srcCorners = [0, 0, this.width, 0, this.width, this.height, 0, this.height];
      var dstCorners = [this.mesh[this.TL].x, this.mesh[this.TL].y, this.mesh[this.TR].x, this.mesh[this.TR].y, this.mesh[this.BR].x, this.mesh[this.BR].y, this.mesh[this.BL].x, this.mesh[this.BL].y];
      this.perspT = perspective_PerspT(srcCorners, dstCorners); // this.warpPerspective = new WarpPerspective(transform);

      var xStep = this.width / (this.resX - 1);
      var yStep = this.height / (this.resY - 1);

      for (var i = 0; i < this.mesh.length; i++) {
        if (this.TL == i || this.BR == i || this.TR == i || this.BL == i) continue;
        var x = i % this.resX;
        var y = Math.floor(i / this.resX);
        x *= xStep;
        y *= yStep; // let point = this.warpPerspective.mapDestPoint(new Point((x, y));
        // this.mesh[i].x = point.getX();
        // this.mesh[i].y = point.getY();

        var dest = this.perspT.transform(x, y);
        this.mesh[i].x = dest[0];
        this.mesh[i].y = dest[1];
      }
    }
  }, {
    key: "displaySurface",
    value: function displaySurface() {
      var isUV = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var tX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var tY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var tW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var tH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      this.pInst.beginShape(this.pInst.TRIANGLES);

      for (var x = 0; x < this.resX - 1; x++) {
        for (var y = 0; y < this.resY - 1; y++) {
          if (isUV) this.getQuadTriangles(x, y, tX, tY, tW, tH);else this.getQuadTrianglesOutline(x, y);
        }
      }

      this.pInst.endShape(this.pInst.CLOSE);
    }
  }, {
    key: "displayCalibration",
    value: function displayCalibration() {
      this.displayGrid();
    }
  }, {
    key: "displayGrid",
    value: function displayGrid() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.controlPointColor;
      this.pInst.strokeWeight(2); // 2

      this.pInst.stroke(col); // col

      this.pInst.fill(this.getMutedControlColor(col));
      var isLogo = false;

      if (isLogo) {
        this.pInst.strokeWeight(6);
        this.pInst.stroke("white");
        this.pInst.fill(50);
      }

      this.pInst.beginShape(this.pInst.TRIANGLES);

      for (var x = 0; x < this.resX - 1; x++) {
        for (var y = 0; y < this.resY - 1; y++) {
          this.getQuadTrianglesOutline(x, y);
        }
      }

      this.pInst.endShape(this.pInst.CLOSE);
    }
  }, {
    key: "getQuadTriangles",
    value: function getQuadTriangles(x, y, tX, tY, tW, tH) {
      ////////////////////////////////
      var mp = this.mesh[x + y * this.resX];
      this.getVertexUV(mp, tX, tY, tW, tH);
      mp = this.mesh[x + 1 + y * this.resX];
      this.getVertexUV(mp, tX, tY, tW, tH); // vertex(1, -1, 0, u, 0);

      mp = this.mesh[x + 1 + (y + 1) * this.resX];
      this.getVertexUV(mp, tX, tY, tW, tH); // vertex(1, 1, 0, u, v);

      this.getVertexUV(mp, tX, tY, tW, tH); // vertex(1, 1, 0, u, v);

      mp = this.mesh[x + (y + 1) * this.resX];
      this.getVertexUV(mp, tX, tY, tW, tH); // vertex(-1, 1, 0, 0, v);

      mp = this.mesh[x + y * this.resX];
      this.getVertexUV(mp, tX, tY, tW, tH); // vertex(-1, -1, 0, 0, 0);
    }
  }, {
    key: "getQuadTrianglesOutline",
    value: function getQuadTrianglesOutline(x, y) {
      var mp = this.mesh[x + y * this.resX];
      this.pInst.vertex(mp.x, mp.y);
      mp = this.mesh[x + 1 + y * this.resX];
      this.pInst.vertex(mp.x, mp.y);
      mp = this.mesh[x + 1 + (y + 1) * this.resX];
      this.pInst.vertex(mp.x, mp.y);
      this.pInst.vertex(mp.x, mp.y);
      mp = this.mesh[x + (y + 1) * this.resX];
      this.pInst.vertex(mp.x, mp.y);
      mp = this.mesh[x + y * this.resX];
      this.pInst.vertex(mp.x, mp.y);
    }
  }, {
    key: "getVertexUV",
    value: function getVertexUV(mp, tX, tY, tW, tH) {
      this.pInst.vertex(mp.x, mp.y, mp.u * this.width * tW - tX, mp.v * this.height * tH - tY);
    }
  }]);

  return QuadMap;
}(surfaces_CornerPinSurface);

/* harmony default export */ const surfaces_QuadMap = (QuadMap);
;// CONCATENATED MODULE: ./src/surfaces/TriMap.js
function TriMap_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TriMap_typeof = function _typeof(obj) { return typeof obj; }; } else { TriMap_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TriMap_typeof(obj); }

function TriMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TriMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function TriMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) TriMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) TriMap_defineProperties(Constructor, staticProps); return Constructor; }

function TriMap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TriMap_setPrototypeOf(subClass, superClass); }

function TriMap_setPrototypeOf(o, p) { TriMap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TriMap_setPrototypeOf(o, p); }

function TriMap_createSuper(Derived) { var hasNativeReflectConstruct = TriMap_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TriMap_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TriMap_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TriMap_possibleConstructorReturn(this, result); }; }

function TriMap_possibleConstructorReturn(self, call) { if (call && (TriMap_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TriMap_assertThisInitialized(self); }

function TriMap_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function TriMap_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function TriMap_getPrototypeOf(o) { TriMap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TriMap_getPrototypeOf(o); }



var TriMap = /*#__PURE__*/function (_CornerPinSurface) {
  TriMap_inherits(TriMap, _CornerPinSurface);

  var _super = TriMap_createSuper(TriMap);

  function TriMap(id, w, h, res, buffer, pInst) {
    var _this;

    TriMap_classCallCheck(this, TriMap);

    _this = _super.call(this, id, w, h, res, "TRI", buffer, pInst);

    _this.setTriMesh();

    return _this;
  }
  /**
   * Returns true if the mouse is over this surface, false otherwise.
   */


  TriMap_createClass(TriMap, [{
    key: "isMouseOver",
    value: function isMouseOver() {
      var mx = this.pInst.mouseX - this.pInst.width / 2;
      var my = this.pInst.mouseY - this.pInst.height / 2;
      if (this.isPointInTriangle(mx - this.x, my - this.y, this.mesh[this.TP], this.mesh[this.BL], this.mesh[this.BR])) return true;
      return false;
    } // Compute barycentric coordinates (u, v, w) for
    // point p with respect to triangle (a, b, c)

  }, {
    key: "Barycentric",
    value: function Barycentric(p, a, b, c, u, v, w) {
      var v0 = b.sub(a),
          v1 = c.sub(a),
          v2 = p.sub(a);
      var d00 = v0.dot(v0);
      var d01 = v0.dot(v1);
      var d11 = v1.dot(v1);
      var d20 = v2.dot(v0);
      var d21 = v2.dot(v1);
      var denom = d00 * d11 - d01 * d01;
      v = (d11 * d20 - d01 * d21) / denom;
      w = (d00 * d21 - d01 * d20) / denom;
      u = 1.0 - v - w;
    }
  }, {
    key: "setTriMesh",
    value: function setTriMesh() {
      this.TP = Math.floor(this.res / 2) - 1;
      this.mesh[this.TP].setControlPoint(true);
      this.mesh[this.TL].setControlPoint(false);
      this.mesh[this.TR].setControlPoint(false);
      this.controlPoints = [];
      this.controlPoints.push(this.mesh[this.TP], this.mesh[this.BL], this.mesh[this.BR]);
    }
  }, {
    key: "displaySurface",
    value: function displaySurface() {
      var isUV = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var tX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var tY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var tW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var tH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      this.pInst.beginShape();
      var u = 0 - tX;
      var v = this.height * tH - tY; // u *= this.width/tW;
      // v *= this.height/tH;

      if (isUV) this.pInst.vertex(this.mesh[this.BL].x, this.mesh[this.BL].y, u, v);else this.pInst.vertex(this.mesh[this.BL].x, this.mesh[this.BL].y);
      u = this.width / 2 * tW - tX;
      v = 0 - tY; // u *= this.width/tW;
      // v *= this.height/tH;

      if (isUV) this.pInst.vertex(this.mesh[this.TP].x, this.mesh[this.TP].y, u, v);else this.pInst.vertex(this.mesh[this.TP].x, this.mesh[this.TP].y);
      u = this.width * tW - tX;
      v = this.height * tH - tY; // u *= this.width/tW;
      // v *= this.height/tH;

      if (isUV) this.pInst.vertex(this.mesh[this.BR].x, this.mesh[this.BR].y, u, v);else this.pInst.vertex(this.mesh[this.BR].x, this.mesh[this.BR].y);
      this.pInst.endShape(this.pInst.CLOSE);
    } // display

  }]);

  return TriMap;
}(surfaces_CornerPinSurface);

/* harmony default export */ const surfaces_TriMap = (TriMap);
;// CONCATENATED MODULE: ./src/surfaces/PolyMap.js
function PolyMap_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PolyMap_typeof = function _typeof(obj) { return typeof obj; }; } else { PolyMap_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PolyMap_typeof(obj); }

function PolyMap_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = PolyMap_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function PolyMap_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PolyMap_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PolyMap_arrayLikeToArray(o, minLen); }

function PolyMap_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function PolyMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PolyMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PolyMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) PolyMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) PolyMap_defineProperties(Constructor, staticProps); return Constructor; }

function PolyMap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PolyMap_setPrototypeOf(subClass, superClass); }

function PolyMap_setPrototypeOf(o, p) { PolyMap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PolyMap_setPrototypeOf(o, p); }

function PolyMap_createSuper(Derived) { var hasNativeReflectConstruct = PolyMap_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PolyMap_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PolyMap_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PolyMap_possibleConstructorReturn(this, result); }; }

function PolyMap_possibleConstructorReturn(self, call) { if (call && (PolyMap_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return PolyMap_assertThisInitialized(self); }

function PolyMap_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function PolyMap_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function PolyMap_getPrototypeOf(o) { PolyMap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PolyMap_getPrototypeOf(o); }


 // TODO
// inside method could be reused in bezier



var PolyMap = /*#__PURE__*/function (_Surface) {
  PolyMap_inherits(PolyMap, _Surface);

  var _super = PolyMap_createSuper(PolyMap);

  function PolyMap(id, numPoints, buffer, pInst) {
    var _this;

    PolyMap_classCallCheck(this, PolyMap);

    _this = _super.call(this, id, 0, 0, 0, "POLY", buffer, pInst);
    _this.points = [];

    for (var i = 0; i < numPoints; i++) {
      var r = 200;
      var x = r + r * Math.cos(i / numPoints * 2 * _this.pInst.PI);
      var y = r + r * Math.sin(i / numPoints * 2 * _this.pInst.PI);
      var cp = new surfaces_MovePoint(PolyMap_assertThisInitialized(_this), x, y, _this.pInst);
      cp.isControlPoint = true;

      _this.points.push(cp);
    }

    _this.setDimensions(_this.points);

    return _this;
  }

  PolyMap_createClass(PolyMap, [{
    key: "setPoints",
    value: function setPoints(pts) {
      this.points = [];

      var _iterator = PolyMap_createForOfIteratorHelper(pts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var cp = new surfaces_MovePoint(this, p.x, p.y, this.pInst);
          cp.isControlPoint = true;
          this.points.push(cp);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "displaySurface",
    value: function displaySurface() {
      var isUV = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var tX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var tY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var tW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.width;
      var tH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.height;

      var _this$getBounds = this.getBounds(this.points),
          x = _this$getBounds.x,
          y = _this$getBounds.y;

      this.pInst.beginShape();

      var _iterator2 = PolyMap_createForOfIteratorHelper(this.points),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var point = _step2.value;

          if (isUV) {
            var dx = point.x - x;
            var dy = point.y - y;
            this.pInst.vertex(point.x, point.y, dx * tW - tX, dy * tH - tY);
          } else this.pInst.vertex(point.x, point.y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.pInst.endShape(this.pInst.CLOSE);
    }
  }, {
    key: "displayControlPoints",
    value: function displayControlPoints() {
      this.pInst.push();
      this.pInst.translate(this.x, this.y, 2);

      var _iterator3 = PolyMap_createForOfIteratorHelper(this.points),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;
          p.display(this.controlPointColor);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.pInst.pop();
    }
  }, {
    key: "isMouseOver",
    value: function isMouseOver() {
      var p = {
        x: this.pInst.mouseX,
        y: this.pInst.mouseY
      }; // developed with p5.js 1.4 when WEBGL mode had a different coordinate system
      // (center was origin in WEBGL mode?)

      if (true) {
        p.x -= this.pInst.width / 2;
        p.y -= this.pInst.height / 2;
      }

      var ins = inside(p, this.points, {
        x: this.x,
        y: this.y
      });
      return ins;
    }
  }, {
    key: "load",
    value: function load(json) {
      var x = json.x,
          y = json.y,
          points = json.points;
      this.x = x;
      this.y = y;

      var _iterator4 = PolyMap_createForOfIteratorHelper(points),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var point = _step4.value;
          var mp = this.points[point.i];
          mp.x = point.x;
          mp.y = point.y;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "getJson",
    value: function getJson() {
      var sJson = {};
      sJson.id = this.id;
      sJson.x = this.x;
      sJson.y = this.y;
      sJson.type = this.type;
      sJson.points = [];

      for (var i = 0; i < this.points.length; i++) {
        var point = {};
        point.i = i;
        point.x = this.points[i].x;
        point.y = this.points[i].y;
        sJson.points.push(point);
      }

      return sJson;
    }
  }, {
    key: "selectSurface",
    value: function selectSurface() {
      // then, see if the poly itself is selected
      if (this.isMouseOver()) {
        this.startDrag();
        return this;
      }

      return null;
    }
  }, {
    key: "selectPoints",
    value: function selectPoints() {
      // check control points
      var _iterator5 = PolyMap_createForOfIteratorHelper(this.points),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var p = _step5.value;

          if (p.isMouseOver()) {
            p.startDrag();
            return p;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return null;
    }
  }]);

  return PolyMap;
}(surfaces_Surface);

/* harmony default export */ const surfaces_PolyMap = (PolyMap);
;// CONCATENATED MODULE: ./src/surfaces/Bezier/BezierPoint.js
function BezierPoint_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BezierPoint_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function BezierPoint_createClass(Constructor, protoProps, staticProps) { if (protoProps) BezierPoint_defineProperties(Constructor.prototype, protoProps); if (staticProps) BezierPoint_defineProperties(Constructor, staticProps); return Constructor; }

// Credit:
// https://geeksoutofthebox.com/2020/11/23/simons-bezier-editor-in-p5-js/
var ControlPoint = /*#__PURE__*/function () {
  function ControlPoint(x, y, parentPath, pInst) {
    BezierPoint_classCallCheck(this, ControlPoint);

    // this.id = parentPath.points.length;
    this.pInst = pInst;
    this.pos = pInst.createVector(x, y);
    this.parentPath = parentPath;
    this.type = "CPOINT";
    this.r = 8;
  }

  BezierPoint_createClass(ControlPoint, [{
    key: "add",
    value: function add(x, y) {
      this.pos.add(x, y);
    }
  }, {
    key: "set",
    value: function set(x, y) {
      this.pos.set(x, y);
    }
  }, {
    key: "select",
    value: function select() {
      var px = this.pos.x + this.parentPath.x;
      var py = this.pos.y + this.parentPath.y;
      var mx = this.pInst.mouseX - this.pInst.width / 2;
      var my = this.pInst.mouseY - this.pInst.height / 2;

      if (this.pInst.dist(px, py, mx, my) < 5) {
        return true;
      }

      return false;
    }
  }, {
    key: "moveTo",
    value: function moveTo() {
      var x = this.pInst.mouseX - this.pInst.width / 2 - this.parentPath.x;
      var y = this.pInst.mouseY - this.pInst.height / 2 - this.parentPath.y;
      var closed = true;
      var path = this.parentPath;
      var i = path.points.indexOf(this);

      if (i % 3 == 0) {
        // anchor (red) points
        var dx = x - this.pos.x;
        var dy = y - this.pos.y;
        this.pos.set(x, y);

        if (i - 1 >= 0 || closed) {
          path.points[path.loopIndex(i - 1)].add(dx, dy);
        }

        if (i + 1 < path.points.length || closed) {
          path.points[path.loopIndex(i + 1)].add(dx, dy);
        }

        if (path.mode == "AUTOMATIC") path.autoSetAllControlPoints();
      } else if (path.mode != "AUTOMATIC") {
        // control (white) points
        this.pos.set(x, y);
        var anchorI = i % 3 == 1 ? i - 1 : i + 1;
        var otherI = i % 3 == 1 ? i - 2 : i + 2;

        if (otherI >= 0 && otherI < path.points.length || closed) {
          var anchor = path.points[path.loopIndex(anchorI)].pos;
          var other = path.points[path.loopIndex(otherI)].pos;

          if (path.mode == "ALIGNED") {
            var dist = p5.Vector.dist(anchor, other);
            var disp = p5.Vector.sub(anchor, this.pos);
            disp.setMag(dist);
            other.set(p5.Vector.add(anchor, disp));
          } else if (path.mode == "MIRRORED") {
            other.set(p5.Vector.lerp(anchor, this.pos, -1));
          }
        }
      }

      path.setDimensions();
    }
  }, {
    key: "isAnchor",
    value: function isAnchor() {
      var i = this.parentPath.points.indexOf(this);
      return i % 3 == 0;
    }
  }, {
    key: "displayControlCircle",
    value: function displayControlCircle() {
      var strokeC = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pInst.color(255, 0, 0);
      var i = this.parentPath.points.indexOf(this);
      this.pInst.stroke(strokeC);
      this.pInst.strokeWeight(2);

      if (i % 3 == 0) {
        // anchor
        this.displayCircle(strokeC, this.r);
      } else if (!this.parentPath.auto) {
        var col = this.parentPath.controlPointColor;
        this.displayCircle(col, this.r - 2);
      }
    }
  }, {
    key: "displayCircle",
    value: function displayCircle(col, r) {
      this.pInst.noFill();
      this.pInst.stroke(col);
      this.pInst.ellipse(this.pos.x, this.pos.y, r * 2);
      this.pInst.noStroke();
      this.pInst.fill(col);
      this.pInst.ellipse(this.pos.x, this.pos.y, r); // const i = this.parentPath.points.indexOf(this);
      // text(i, this.pos.x, this.pos.y+20);
    }
  }]);

  return ControlPoint;
}();

/* harmony default export */ const BezierPoint = (ControlPoint);
;// CONCATENATED MODULE: ./src/surfaces/Bezier/BezierMap.js
function BezierMap_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { BezierMap_typeof = function _typeof(obj) { return typeof obj; }; } else { BezierMap_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return BezierMap_typeof(obj); }

function BezierMap_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = BezierMap_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function BezierMap_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return BezierMap_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return BezierMap_arrayLikeToArray(o, minLen); }

function BezierMap_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function BezierMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BezierMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function BezierMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) BezierMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) BezierMap_defineProperties(Constructor, staticProps); return Constructor; }

function BezierMap_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { BezierMap_get = Reflect.get; } else { BezierMap_get = function _get(target, property, receiver) { var base = BezierMap_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return BezierMap_get(target, property, receiver || target); }

function BezierMap_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = BezierMap_getPrototypeOf(object); if (object === null) break; } return object; }

function BezierMap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) BezierMap_setPrototypeOf(subClass, superClass); }

function BezierMap_setPrototypeOf(o, p) { BezierMap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return BezierMap_setPrototypeOf(o, p); }

function BezierMap_createSuper(Derived) { var hasNativeReflectConstruct = BezierMap_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = BezierMap_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = BezierMap_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return BezierMap_possibleConstructorReturn(this, result); }; }

function BezierMap_possibleConstructorReturn(self, call) { if (call && (BezierMap_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return BezierMap_assertThisInitialized(self); }

function BezierMap_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function BezierMap_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function BezierMap_getPrototypeOf(o) { BezierMap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return BezierMap_getPrototypeOf(o); }

// Credit:
// https://geeksoutofthebox.com/2020/11/23/simons-bezier-editor-in-p5-js/



var BezierMap = /*#__PURE__*/function (_Surface) {
  BezierMap_inherits(BezierMap, _Surface);

  var _super = BezierMap_createSuper(BezierMap);

  function BezierMap(id, numPoints, pMapper, pInst) {
    var _this;

    BezierMap_classCallCheck(this, BezierMap);

    _this = _super.call(this, id, 0, 0, 0, "BEZ", pMapper.buffer, pInst);
    _this.pMapper = pMapper;
    _this.bufferSpace = 10;
    _this.width = 100;
    _this.height = 100;

    _this.initEmpty(numPoints);

    _this.mode = "FREE";
    _this.r = 8;
    return _this;
  }

  BezierMap_createClass(BezierMap, [{
    key: "initEmpty",
    value: function initEmpty() {
      var numAnchors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      this.points = [];
      this.x = 0;
      this.y = 0;
      var r = 100;
      var lineW = 50;
      var x = r * Math.cos(0);
      var y = r * Math.sin(0);
      var x0 = lineW * Math.cos(Math.PI / 2);
      var y0 = -lineW * Math.sin(Math.PI / 2);
      var x1 = -x0;
      var y1 = -y0;
      this.points.push(new BezierPoint(x, y, this, this.pInst));
      this.points.push(new BezierPoint(x + x1, y + y1, this, this.pInst));

      for (var i = 1; i < numAnchors; i++) {
        var ang = i * 2 * Math.PI / numAnchors;

        var _x = r * Math.cos(ang);

        var _y = r * Math.sin(ang);

        var _x2 = -lineW * Math.cos(Math.PI / 2 - ang);

        var _y2 = lineW * Math.sin(Math.PI / 2 - ang);

        var _x3 = -_x2;

        var _y3 = -_y2;

        this.points.push(new BezierPoint(_x + _x3, _y + _y3, this, this.pInst));
        this.points.push(new BezierPoint(_x, _y, this, this.pInst));
        this.points.push(new BezierPoint(_x + _x2, _y + _y2, this, this.pInst));
      }

      this.points.push(new BezierPoint(x + x0, y + y0, this, this.pInst)); //
      // this.points.push(new BezierPoint( r * Math.cos(ang2),  r * sin(ang2), this));
      //

      this.closed = true;
      this.auto = false;
    }
  }, {
    key: "setAlignedMode",
    value: function setAlignedMode() {
      this.mode = "ALIGNED";
    }
  }, {
    key: "setMirroredMode",
    value: function setMirroredMode() {
      this.mode = "MIRRORED";
    }
  }, {
    key: "setFreeMode",
    value: function setFreeMode() {
      this.mode = "FREE";
    }
  }, {
    key: "setAutomaticMode",
    value: function setAutomaticMode() {
      this.mode = "AUTOMATIC";
    }
  }, {
    key: "setBezierDetail",
    value: function setBezierDetail() {
      var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
      this.pMapper.bezBuffer.bezierDetail(num);
      this.pMapper.buffer.bezierDetail(num);
    }
  }, {
    key: "isReady",
    value: function isReady() {
      return this.pMapper.bezBuffer && this.pMapper.bezierShaderLoaded;
    }
  }, {
    key: "load",
    value: function load(json) {
      this.points = [];
      this.x = json.x;
      this.y = json.y;
      this.closed = json.closed;
      this.auto = json.auto;

      var _iterator = BezierMap_createForOfIteratorHelper(json.points),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          this.points.push(new BezierPoint(p.x, p.y, this, this.pInst));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.setDimensions();
    }
  }, {
    key: "getJson",
    value: function getJson() {
      return {
        id: this.id,
        type: this.type,
        x: this.x,
        y: this.y,
        points: this.points.map(function (p) {
          return {
            x: p.pos.x,
            y: p.pos.y
          };
        }),
        closed: this.closed,
        auto: this.auto
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return JSON.stringify(this.getJson());
    }
  }, {
    key: "selectSurface",
    value: function selectSurface() {
      if (this.isMouseOver()) {
        this.startDrag();
        return this;
      }

      return null;
    }
  }, {
    key: "selectPoints",
    value: function selectPoints() {
      // check if control points are selected
      var controls = this.selectControls();
      if (controls) return controls;
      return this.selectAnchors();
    }
  }, {
    key: "selectAnchors",
    value: function selectAnchors() {
      // check if control points are selected
      for (var i = 0; i < this.points.length; i += 3) {
        var p = this.points[i];

        if (p.select()) {
          return p;
        }
      }

      return null;
    }
  }, {
    key: "selectControls",
    value: function selectControls() {
      // check if control points are selected
      var _iterator2 = BezierMap_createForOfIteratorHelper(this.points),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          if (p.isAnchor()) {
            continue;
          } else if (p.select()) return p;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return null;
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var polyline = this.getPolyline();
      return BezierMap_get(BezierMap_getPrototypeOf(BezierMap.prototype), "getBounds", this).call(this, polyline);
    }
  }, {
    key: "loopIndex",
    value: function loopIndex(i) {
      return (i + this.points.length) % this.points.length;
    }
  }, {
    key: "toggleClosed",
    value: function toggleClosed() {
      if (this.closed) {
        this.closed = false;
        this.points.pop();
        this.points.pop();
      } else {
        this.closed = true;
        var anchor1 = this.points[this.points.length - 1].pos;
        var control1 = this.points[this.points.length - 2].pos;
        var anchor2 = this.points[0].pos;
        var control2 = this.points[1].pos;
        var newControl1 = p5.Vector.lerp(anchor1, control1, -1);
        var cp1 = new BezierPoint(newControl1.x, newControl1.y, this, this.pInst);
        var newControl2 = p5.Vector.lerp(anchor2, control2, -1);
        var cp2 = new BezierPoint(newControl2.x, newControl2.y, this, this.pInst);
        this.points.push(cp1, cp2);
      }

      this.setDimensions();
    }
  }, {
    key: "setDimensions",
    value: function setDimensions() {
      var _this$getBounds = this.getBounds(),
          w = _this$getBounds.w,
          h = _this$getBounds.h;

      this.width = w + this.bufferSpace * 2;
      this.height = h + this.bufferSpace * 2; // editing the mask buffer of one bezier affects the others

      var bezBuffer = this.pMapper.bezBuffer;
      this.displayBezierPG(bezBuffer);
    }
  }, {
    key: "numSegments",
    value: function numSegments() {
      return Math.floor(this.points.length / 3);
    }
  }, {
    key: "getSegment",
    value: function getSegment(i) {
      return [this.points[this.loopIndex(i * 3 + 0)], this.points[this.loopIndex(i * 3 + 1)], this.points[this.loopIndex(i * 3 + 2)], this.points[this.loopIndex(i * 3 + 3)]];
    }
  }, {
    key: "addSegment",
    value: function addSegment(x, y) {
      if (!x) {
        x = this.pInst.mouseX - this.pInst.width / 2 - this.x;
      }

      if (!y) {
        y = this.pInst.mouseY - this.pInst.height / 2 - this.y;
      }

      var closestAnchorId = this.getClosestAnchor();
      var nextClosestAnchorId = this.getNextClosestAnchor();
      var prevControl = this.points[closestAnchorId + 1].pos;
      var nextControlID = nextClosestAnchorId - 1;

      if (nextControlID == -1) {
        nextControlID = this.points.length - 1;
      }

      var nextControl = this.points[nextControlID].pos;
      var anchor = this.pInst.createVector(x, y);
      var aP = new BezierPoint(anchor.x, anchor.y, this, this.pInst);
      var control1 = p5.Vector.lerp(prevControl, anchor, 1 - 0.3);
      var control2 = p5.Vector.lerp(anchor, nextControl, 0.3);
      var cp1 = new BezierPoint(control1.x, control1.y, this, this.pInst);
      var cp2 = new BezierPoint(control2.x, control2.y, this, this.pInst);
      this.points.splice(closestAnchorId + 2, 0, cp1, aP, cp2);
    }
  }, {
    key: "removeSegment",
    value: function removeSegment() {
      if (this.points.length <= 3) {
        console.warn("cannot have a bezier with less than one anchor");
        return;
      }

      for (var i = 0; i < this.points.length; i += 3) {
        if (this.points[i].select()) {
          this.points.splice(i, 3);
        }
      }
    }
  }, {
    key: "getClosestAnchor",
    value: function getClosestAnchor() {
      var mx = this.pInst.mouseX - this.pInst.width / 2 - this.x;
      var my = this.pInst.mouseY - this.pInst.height / 2 - this.y;
      var minDis = Infinity;
      var index = 0;

      for (var i = 0; i < this.points.length; i += 3) {
        if (i >= this.points.length - 3) {
          var p0 = this.points[i];
          var p1 = this.points[0];
        } else {
          var p0 = this.points[i];
          var p1 = this.points[i + 3];
        }

        var d0 = this.pInst.dist(p0.pos.x, p0.pos.y, mx, my);
        var d1 = this.pInst.dist(p1.pos.x, p1.pos.y, mx, my);

        if (d0 + d1 < minDis) {
          minDis = d0 + d1;
          index = i;
        }
      }

      return index;
    }
  }, {
    key: "getNextClosestAnchor",
    value: function getNextClosestAnchor() {
      var anchor = this.getClosestAnchor();
      var next = anchor + 3;
      if (next > this.points.length - 3) next = 0;
      return next;
    }
  }, {
    key: "autoSetControlPoint",
    value: function autoSetControlPoint(anchorI, controlSpacing) {
      if ((anchorI - 3 < 0 || anchorI + 3 >= this.points.length) && !this.closed) return;
      var anchorLeftI = this.loopIndex(anchorI - 3);
      var anchorRightI = this.loopIndex(anchorI + 3);
      var anchor = this.points[anchorI];
      var anchorLeft = this.points[anchorLeftI];
      var anchorRight = this.points[anchorRightI];
      var dispLeft = p5.Vector.sub(anchorLeft, anchor);
      var dispRight = p5.Vector.sub(anchorRight, anchor);
      var magLeft = dispLeft.mag();
      var magRight = dispRight.mag();
      dispLeft.normalize();
      dispRight.normalize();
      var dirLeft = p5.Vector.sub(dispLeft, dispRight);
      var dirRight = p5.Vector.sub(dispRight, dispLeft);
      dirLeft.setMag(magLeft * controlSpacing);
      dirRight.setMag(magRight * controlSpacing);
      this.points[this.loopIndex(anchorI - 1)].set(p5.Vector.add(anchor, dirLeft));
      this.points[this.loopIndex(anchorI + 1)].set(p5.Vector.add(anchor, dirRight));
    }
  }, {
    key: "autoSetEdgePoints",
    value: function autoSetEdgePoints(controlSpacing) {
      if (this.closed) return;
      this.points[1].set(p5.Vector.lerp(this.points[0].pos, this.points[2].pos, controlSpacing));
      this.points[this.points.length - 2].set(p5.Vector.lerp(this.points[this.points.length - 1].pos, this.points[this.points.length - 3].pos, controlSpacing));
    }
  }, {
    key: "autoSetAllControlPoints",
    value: function autoSetAllControlPoints(controlSpacing) {
      for (var i = 0; i < this.points.length; i += 3) {
        this.autoSetControlPoint(i, controlSpacing);
      }

      this.autoSetEdgePoints(controlSpacing);
    }
  }, {
    key: "display",
    value: function display() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pInst.color("black");
      this.pInst.noStroke();
      this.pInst.fill(col);
      this.displayBezier();
      this.displayCalib();
    }
  }, {
    key: "displayCalib",
    value: function displayCalib() {
      if (this.pInst.isCalibratingMapper()) {
        this.pInst.strokeWeight(3);
        this.pInst.stroke(this.controlPointColor);
        this.pInst.fill(this.getMutedControlColor());
        this.displayBezier();
      }
    }
  }, {
    key: "displayTexture",
    value: function displayTexture(img) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var texW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var texH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

      if (!this.isReady()) {
        return;
      }

      var buffer = this.pMapper.buffer;
      this.drawImage(img, buffer, x, y, texW, texH);
      this.displayGraphicsTexture(buffer);
      this.displayCalib();
    }
  }, {
    key: "displaySketch",
    value: function displaySketch(sketch) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var tW = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var tH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var buffer = this.pMapper.buffer;
      buffer.push(); // TODO
      // WEBGL origin or 2D origin ...
      // Does this make sense?
      // draw the sketch from top left corner
      // buffer.translate(-buffer.width / 2, -buffer.height / 2);
      // could also put graphics buffer
      // at center of bezier
      // const {w, h} = this.getBounds();
      // buffer.translate(w/2, h/2);

      buffer.translate(x, y);
      sketch(buffer);
      buffer.pop();
      this.displayGraphicsTexture(buffer);
    }
  }, {
    key: "displayGraphicsTexture",
    value: function displayGraphicsTexture(pBuffer) {
      if (!this.isReady()) {
        return;
      } // white bezier mask should be recreated every time
      // shape changes (this.setDimensions())


      this.setDimensions();
      var pMask = this.pMapper.bezBuffer; // let theShader = this.pMapper.bezShader;

      var pOutput = this.pMapper.bufferWEBGL; // had to clear for 1.9

      pOutput.clear();
      var frag = "// https://github.com/aferriss/p5jsShaderExamples \n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        // grab texcoords from vert shader\n        varying vec2 vTexCoord;\n        \n        // our texture coming from p5\n        uniform sampler2D texMask;\n        uniform sampler2D texImg;\n        \n        \n        void main() {\n          vec2 uv = vTexCoord;\n          \n          // the texture is loaded upside down and backwards by default so lets flip it\n          uv.y = 1.0 - uv.y;\n          \n          vec4 maskT = texture2D(texMask, uv);\n          vec4 imgT = texture2D(texImg, uv);\n          \n          float gray = (maskT.r + maskT.g + maskT.b) / 3.0;\n        \n          // mask\n          float threshR = imgT.r* gray ;\n          float threshG = imgT.g* gray ;\n          float threshB = imgT.b* gray ;\n          vec3 thresh = vec3(threshR, threshG, threshB);\n        \n          // render the output\n          gl_FragColor = vec4(thresh, gray);\n        }";
      var vert = "// vert file and comments from adam ferriss\n        // https://github.com/aferriss/p5jsShaderExamples\n        \n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        // our vertex data\n        attribute vec3 aPosition;\n        attribute vec2 aTexCoord;\n        \n        // lets get texcoords just for fun! \n        varying vec2 vTexCoord;\n        \n        void main() {\n          // copy the texcoords\n          vTexCoord = aTexCoord;\n        \n          // copy the position data into a vec4, using 1.0 as the w component\n          vec4 positionVec4 = vec4(aPosition, 1.0);\n          positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n        \n          // send the vertex information on to the fragment shader\n          gl_Position = positionVec4;\n        }"; // TODO - no need to create this every time... (?)
      // for some reason didn't work in the ProjectionMapper class...

      var theShader = pOutput.createShader(vert, frag);
      pOutput.setAttributes("alpha", true);
      pOutput.shader(theShader);
      theShader.setUniform("resolution", [this.pInst.width, this.pInst.height]);
      theShader.setUniform("time", millis() / 1000.0);
      theShader.setUniform("mouse", [this.pInst.mouseX, this.pInst.map(this.pInst.mouseY, 0, this.pInst.height, this.pInst.height, 0)]);
      theShader.setUniform("texMask", pMask);
      theShader.setUniform("texImg", pBuffer);
      pOutput.rect(0, 0, this.pInst.width, this.pInst.height);

      var _this$getBounds2 = this.getBounds(),
          x = _this$getBounds2.x,
          y = _this$getBounds2.y;

      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.pInst.translate(x - this.bufferSpace, y - this.bufferSpace);
      this.pInst.image(pOutput, 0, 0);
      this.pInst.pop();
      this.displayCalib();
    }
  }, {
    key: "drawImage",
    value: function drawImage(img, pg) {
      var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var texW = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var texH = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      if (img && pg) {
        if (texH <= 0) texW = img.width;
        if (texH <= 0) texH = img.height;
        pg.push();
        pg.clear(); // useful for WEBGL mode...
        // pg.translate(-pg.width / 2, -pg.height / 2);

        pg.translate(x, y);
        pg.image(img, 0, 0, texW, texH);
        pg.pop();
      }
    }
  }, {
    key: "displayBezierPG",
    value: function displayBezierPG(pg) {
      var _this$getBounds3 = this.getBounds(),
          x = _this$getBounds3.x,
          y = _this$getBounds3.y;

      pg.push();
      pg.clear();
      pg.fill("white");
      pg.translate(-x, -y);
      pg.translate(this.bufferSpace, this.bufferSpace);
      pg.beginShape();
      pg.vertex(this.points[0].pos.x, this.points[0].pos.y);

      for (var i = 0; i < this.numSegments(); i++) {
        var seg = this.getSegment(i);
        pg.bezierVertex(seg[1].pos.x, seg[1].pos.y, seg[2].pos.x, seg[2].pos.y, seg[3].pos.x, seg[3].pos.y);
      }

      pg.endShape();
      pg.pop();
    }
  }, {
    key: "displayBezier",
    value: function displayBezier() {
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.pInst.beginShape();
      this.pInst.vertex(this.points[0].pos.x, this.points[0].pos.y);

      for (var i = 0; i < this.numSegments(); i++) {
        var seg = this.getSegment(i);
        this.pInst.bezierVertex(seg[1].pos.x, seg[1].pos.y, seg[2].pos.x, seg[2].pos.y, seg[3].pos.x, seg[3].pos.y);
      }

      this.pInst.endShape();
      this.pInst.pop();
    }
  }, {
    key: "displayControlPoints",
    value: function displayControlPoints() {
      if (this.pInst.isMovingPoints()) {
        var lineC = this.controlPointColor;
        this.pInst.push();
        this.pInst.translate(this.x, this.y);

        if (!this.auto) {
          this.displayControlLines(lineC);
        }

        this.displayControlCircles(this.pInst.color("red"));
        this.pInst.pop();
      }
    }
  }, {
    key: "displayControlLines",
    value: function displayControlLines(strokeC) {
      this.pInst.strokeWeight(2);

      for (var i = 0; i < this.numSegments(); i++) {
        var seg = this.getSegment(i);
        this.pInst.stroke(strokeC);
        this.pInst.line(seg[0].pos.x, seg[0].pos.y, seg[1].pos.x, seg[1].pos.y);
        this.pInst.line(seg[2].pos.x, seg[2].pos.y, seg[3].pos.x, seg[3].pos.y);
      }
    }
  }, {
    key: "displayControlCircles",
    value: function displayControlCircles(anchorCol) {
      var i = 0;
      var index = this.getClosestAnchor();
      var nextIndex = this.getNextClosestAnchor();

      var _iterator3 = BezierMap_createForOfIteratorHelper(this.points),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;
          var col = anchorCol;

          if (i == index) {
            col = this.pInst.color(255, 200, 200);
          } else if (i == nextIndex) {
            col = this.pInst.color(255, 200, 200);
          }

          p.displayControlCircle(col);
          i++;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "getPolyline",
    value: function getPolyline() {
      var polyline = [];

      for (var i = 0; i < this.numSegments(); i++) {
        var seg = this.getSegment(i);
        var steps = 4;

        for (var _i = 0; _i <= steps; _i++) {
          var t = _i / steps;
          var x = this.pInst.bezierPoint(seg[0].pos.x, seg[1].pos.x, seg[2].pos.x, seg[3].pos.x, t);
          var y = this.pInst.bezierPoint(seg[0].pos.y, seg[1].pos.y, seg[2].pos.y, seg[3].pos.y, t);
          polyline.push({
            x: x,
            y: y
          });
        }
      }

      return polyline;
    } //(x0,y0) is start point; (x1,y1),(x2,y2) is control points; (x3,y3) is end point.

  }, {
    key: "isMouseOver",
    value: function isMouseOver() {
      var polyline = this.getPolyline();
      var mx = this.pInst.mouseX - this.pInst.width / 2 - this.x;
      var my = this.pInst.mouseY - this.pInst.height / 2 - this.y;
      return this.inside(mx, my, polyline);
    }
  }, {
    key: "inside",
    value: function inside(x, y, vs) {
      // ray-casting algorithm based on
      // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html
      var inside = false;

      for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i].x,
            yi = vs[i].y;
        var xj = vs[j].x,
            yj = vs[j].y;
        var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }

      return inside;
    } // https://editor.p5js.org/mikima/sketches/SkEXyPvpf
    // pg_mask

  }]);

  return BezierMap;
}(surfaces_Surface);

/* harmony default export */ const Bezier_BezierMap = (BezierMap);
;// CONCATENATED MODULE: ./src/lines/LineMap.js
function LineMap_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { LineMap_typeof = function _typeof(obj) { return typeof obj; }; } else { LineMap_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return LineMap_typeof(obj); }

function LineMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function LineMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function LineMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) LineMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) LineMap_defineProperties(Constructor, staticProps); return Constructor; }

function LineMap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) LineMap_setPrototypeOf(subClass, superClass); }

function LineMap_setPrototypeOf(o, p) { LineMap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LineMap_setPrototypeOf(o, p); }

function LineMap_createSuper(Derived) { var hasNativeReflectConstruct = LineMap_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LineMap_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LineMap_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LineMap_possibleConstructorReturn(this, result); }; }

function LineMap_possibleConstructorReturn(self, call) { if (call && (LineMap_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return LineMap_assertThisInitialized(self); }

function LineMap_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function LineMap_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function LineMap_getPrototypeOf(o) { LineMap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LineMap_getPrototypeOf(o); }



 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LINE CLASS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var LineMap = /*#__PURE__*/function (_Draggable) {
  LineMap_inherits(LineMap, _Draggable);

  var _super = LineMap_createSuper(LineMap);

  function LineMap(x0, y0, x1, y1, id, pInst) {
    var _this;

    LineMap_classCallCheck(this, LineMap);

    _this = _super.call(this, pInst, 0, 0);
    _this.id = id;
    _this.x = 0;
    _this.y = 0;
    _this.type = "LINE";
    _this.lineW = 10;
    _this.endCapsOn = true;
    _this.lastChecked = 0;
    _this.lineC = _this.pInst.color(255);
    _this.highlightColor = _this.pInst.color(0, 255, 0);
    _this.controlPointColor = getRandomizedColor(_this.id, _this.type, _this.pInst);
    _this.p0 = new surfaces_MovePoint(LineMap_assertThisInitialized(_this), x0, y0, _this.pInst);
    _this.p1 = new surfaces_MovePoint(LineMap_assertThisInitialized(_this), x1, y1, _this.pInst); // this.controlCol = getRandomizedColor(this.pInst, this.id+1, this.type);

    _this.leftToRight();

    _this.ang = _this.pInst.atan2(_this.p0.y - _this.p1.y, _this.p0.x - _this.p1.x);
    if (_this.ang > _this.pInst.PI / 2) _this.ang -= 2 * _this.pInst.PI;
    return _this;
  } //////////////////////////////////////////////
  // LOADING / SAVING
  //////////////////////////////////////////////


  LineMap_createClass(LineMap, [{
    key: "load",
    value: function load(json) {
      this.x = json.x;
      this.y = json.y;
      this.p0.x = json.x0;
      this.p0.y = json.y0;
      this.p1.x = json.x1;
      this.p1.y = json.y1;
    }
  }, {
    key: "getJson",
    value: function getJson() {
      var json = {};
      json.id = this.id;
      json.x = this.x;
      json.y = this.y;
      json.x0 = this.p0.x;
      json.y0 = this.p0.y;
      json.x1 = this.p1.x;
      json.y1 = this.p1.y;
      return json;
    } //////////////////////////////////////////////
    // DISPLAY METHODS
    //////////////////////////////////////////////

  }, {
    key: "display",
    value: function display() {
      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lineC;
      this.pInst.strokeWeight(this.lineW);
      this.pInst.stroke(col);
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.pInst.line(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
      this.drawEndCaps(this.p0, this.p1, col, col);
      this.pInst.pop();
    }
  }, {
    key: "displayCenterPulse",
    value: function displayCenterPulse(per) {
      var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lineC;
      // per = constrain(per, 0, 1.0);
      // let per = this. getPercentWave(this.pInst, speed);
      var midX = (this.p0.x + this.p1.x) / 2;
      var midY = (this.p0.y + this.p1.y) / 2;
      var x0 = this.pInst.map(per, 0, 1.0, midX, this.p0.x);
      var x1 = this.pInst.map(per, 0, 1.0, midX, this.p1.x);
      var y0 = this.pInst.map(per, 0, 1.0, midY, this.p0.y);
      var y1 = this.pInst.map(per, 0, 1.0, midY, this.p1.y);
      this.pInst.strokeWeight(this.lineW);
      this.pInst.stroke(col);
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.pInst.line(x0, y0, x1, y1);
      this.drawEndCaps({
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }, col, col);
      this.pInst.pop();
    }
  }, {
    key: "displayPercent",
    value: function displayPercent(per) {
      var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lineC;
      var p = per;
      var p0 = this.pInst.createVector(this.p0.x, this.p0.y);
      var p1 = this.pInst.createVector(this.p1.x, this.p1.y);
      var pTemp = p5.Vector.lerp(p0, p1, p);
      this.pInst.strokeWeight(this.lineW);
      this.pInst.stroke(col);
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.pInst.line(this.p0.x, this.p0.y, pTemp.x, pTemp.y);
      this.drawEndCaps(p0, pTemp, col, col);
      this.pInst.pop();
    }
  }, {
    key: "displayPercentWidth",
    value: function displayPercentWidth(per) {
      var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lineC;
      per = this.pInst.constrain(per, 0, 1.0);
      var sw = this.pInst.map(per, 0, 1.0, 0, 10);
      this.pInst.strokeWeight(sw);
      this.pInst.stroke(col);
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.pInst.line(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
      this.drawEndCaps(this.p0, this.p1, col, col, sw);
      this.pInst.pop();
    }
  }, {
    key: "displayNone",
    value: function displayNone() {
      this.display(this.pInst.color(0));
    }
  }, {
    key: "displayRainbowCycle",
    value: function displayRainbowCycle() {
      // TODO - is this how we should handle color modes?
      // shouldn't we set to what it was before call? Can't presume RBG
      this.pInst.colorMode(HSB, 255);
      var col = this.pInst.color(this.pInst.frameCount % 255, 255, 255);
      this.display(col);
      this.pInst.colorMode(this.pInst.RGB, 255);
    } // TODO
    // way too expensive

  }, {
    key: "displayGradientLine",
    value: function displayGradientLine(c1, c2, per) {
      var phase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var flip = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      per += phase;
      per %= 1;
      var spacing = 1.0 / height;

      for (var i = 0; i < 1.0; i += spacing) {
        var grad = (i / 2 + per) % 1;
        var col = this.get2CycleColor(c1, c2, grad);
        this.displaySegment(i, spacing, col);
      }
    } //////////////////////////////////////////////
    // DISPLAY HELPERS
    //////////////////////////////////////////////

  }, {
    key: "displayCalibration",
    value: function displayCalibration() {
      this.pInst.colorMode(this.pInst.HSB, 255);
      var h = this.pInst.hue(this.controlPointColor);
      var col = this.pInst.color((h + 80) % 255, 255, 255);
      this.pInst.colorMode(this.pInst.RGB);

      if (this.isMouseOver()) {
        col = this.pInst.color(255);
      }

      this.display(col);
    }
  }, {
    key: "displayControlPoints",
    value: function displayControlPoints() {
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      this.p0.display(this.controlPointColor);
      this.p1.display(this.controlPointColor);
      this.pInst.pop();
    }
  }, {
    key: "setEndCapsOn",
    value: function setEndCapsOn() {
      this.endCapsOn = true;
    }
  }, {
    key: "setEndCapsOff",
    value: function setEndCapsOff() {
      this.endCapsOn = false;
    }
  }, {
    key: "drawEndCaps",
    value: function drawEndCaps(p0, p1) {
      var col0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.lineC;
      var col1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.lineC;

      if (!this.endCapsOn) {
        return;
      }

      this.pInst.noStroke();

      if (this.pInst.dist(p0.x, p0.y, p1.x, p1.y) > 1) {
        this.pInst.fill(col0);
        this.pInst.ellipse(p0.x, p0.y, this.lineW);
        this.pInst.fill(col1);
        this.pInst.ellipse(p1.x, p1.y, this.lineW);
      }
    }
  }, {
    key: "displaySegment",
    value: function displaySegment(startPer, sizePer) {
      var col = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.lineC;
      this.pInst.strokeWeight(this.lineW);
      this.pInst.stroke(col);
      var p0 = this.pInst.createVector(this.p0.x, this.p0.y);
      var p1 = this.pInst.createVector(this.p1.x, this.p1.y);
      var pTemp = p5.Vector.lerp(p0, p1, startPer);
      this.pInst.push();
      this.pInst.translate(this.x, this.y);
      var pTempEnd = p5.Vector.lerp(pTemp, p1, startPer + sizePer);
      this.pInst.line(pTemp.x, pTemp.y, pTempEnd.x, pTempEnd.y);
      this.drawEndCaps(pTemp, pTempEnd, col, col);
      this.pInst.pop();
    } //////////////////////////////////////////////
    // COLOR HELPERS
    //////////////////////////////////////////////

  }, {
    key: "get2CycleColor",
    value: function get2CycleColor(c1, c2, per) {
      per = this.pInst.constrain(per, 0, 1);
      per *= 2;

      if (per < 1) {
        return this.pInst.lerpColor(c1, c2, per);
      } else {
        per = this.pInst.map(per, 1, 2, 0, 1);
        return this.pInst.lerpColor(c2, c1, per);
      }
    }
  }, {
    key: "get3CycleColor",
    value: function get3CycleColor(c1, c2, per) {
      per = this.pInst.constrain(per, 0, 1);
      per *= 3;

      if (per < 1) {
        return this.pInst.lerpColor(c1, c2, per);
      } else if (per < 2) {
        per = this.pInst.map(per, 1, 2, 1, 0);
        return this.pInst.lerpColor(c3, c2, per);
      } else {
        per = this.pInst.map(per, 2, 3, 1, 0);
        return this.pInst.lerpColor(c1, c3, per);
      }
    }
  }, {
    key: "getPointHighlight",
    value: function getPointHighlight(p) {
      this.pInst.colorMode(this.pInst.RGB, 255);
      if (this.isMouseOverPoint(p)) this.pInst.stroke(0, 255, 0);else this.pInst.stroke(255, 0, 0);
    } //////////////////////////////////////////////
    // CLICK DETECTION
    //////////////////////////////////////////////
    // www.jeffreythompson.org/collision-detection/line-point.php

  }, {
    key: "isMouseOver",
    value: function isMouseOver() {
      var x1 = this.p0.x;
      var y1 = this.p0.y;
      var x2 = this.p1.x;
      var y2 = this.p1.y;
      var px = this.pInst.mouseX - this.pInst.width / 2 - this.x;
      var py = this.pInst.mouseY - this.pInst.height / 2 - this.y;
      var d1 = this.pInst.dist(px, py, x1, y1);
      var d2 = this.pInst.dist(px, py, x2, y2);
      var lineLen = this.pInst.dist(x1, y1, x2, y2);
      var buffer = 0.15 * this.lineW; // higher # = less accurate

      if (d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer) {
        return true;
      }

      return false;
    }
  }, {
    key: "selectSurface",
    value: function selectSurface() {
      if (this.isMouseOver()) {
        this.startDrag();
        return this;
      }

      return null;
    }
  }, {
    key: "selectPoints",
    value: function selectPoints() {
      // check control points
      if (this.p0.isMouseOver()) {
        this.p0.startDrag();
        return this.p0;
      }

      if (this.p1.isMouseOver()) {
        this.p1.startDrag();
        return this.p1;
      }

      return null;
    } //////////////////////////////////////////////
    // OTHER HELPERS
    //////////////////////////////////////////////

  }, {
    key: "leftToRight",
    value: function leftToRight() {
      if (this.p0.x > this.p1.x) {
        var temp = this.pInst.createVector(this.p0.x, this.p0.y);
        this.p0.set(this.p1);
        this.p1.set(temp);
      }
    }
  }, {
    key: "rightToLeft",
    value: function rightToLeft() {
      if (this.p0.x < this.p1.x) {
        var temp = this.pInst.createVector(this.p0.x, this.p0.y);
        this.p0.set(this.p1);
        this.p1.set(temp);
      }
    }
  }]);

  return LineMap;
}(surfaces_Draggable);

/* harmony default export */ const lines_LineMap = (LineMap);
;// CONCATENATED MODULE: ./src/ProjectionMapper.js
function ProjectionMapper_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = ProjectionMapper_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function ProjectionMapper_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ProjectionMapper_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ProjectionMapper_arrayLikeToArray(o, minLen); }

function ProjectionMapper_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ProjectionMapper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ProjectionMapper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ProjectionMapper_createClass(Constructor, protoProps, staticProps) { if (protoProps) ProjectionMapper_defineProperties(Constructor.prototype, protoProps); if (staticProps) ProjectionMapper_defineProperties(Constructor, staticProps); return Constructor; }








var ProjectionMapper = /*#__PURE__*/function () {
  function ProjectionMapper() {
    ProjectionMapper_classCallCheck(this, ProjectionMapper);

    this.buffer; // for pOutput bezier

    this.bufferWEBGL;
    this.surfaces = [];
    this.lines = [];
    this.dragged = null;
    this.selected = null;
    this.calibrate = false;
    this.pInst = null;
    this.pMousePressed = false;
    this.moveMode = "ALL";
    this.bezBuffer = null;
    this.bezShader = null;
    this.bezierShaderLoaded = false;
    this.lastFrame = -1;
  }

  ProjectionMapper_createClass(ProjectionMapper, [{
    key: "preload",
    value: function preload(shader) {
      this.bezShader = shader;
      this.bezierShaderLoaded = true;
    }
  }, {
    key: "init",
    value: function init(w, h) {
      if (this.bezBuffer == null) {
        this.bufferWEBGL = this.pInst.createGraphics(w, h, this.pInst.WEBGL); // TODO
        // should these be WEBGL??
        // warning about reading frequently??
        // https://stackoverflow.com/questions/74020182/canvas2d-multiple-readback-operations-using-getimagedata-are-faster-with-the-wi

        this.buffer = this.pInst.createGraphics(w, h);
        this.bezBuffer = this.pInst.createGraphics(w, h);
        this.initPMapperShaderStr();
      }
    } // TODO - doesn't work for some reason?
    // I'm honestly very confused; seems to need this and
    // redefining in BezierMap.js?
    // https://github.com/processing/p5.js/issues/4899

  }, {
    key: "initPMapperShaderStr",
    value: function initPMapperShaderStr() {
      var frag = "// https://github.com/aferriss/p5jsShaderExamples \n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        // grab texcoords from vert shader\n        varying vec2 vTexCoord;\n        \n        // our texture coming from p5\n        uniform sampler2D texMask;\n        uniform sampler2D texImg;\n        \n        \n        void main() {\n          vec2 uv = vTexCoord;\n          \n          // the texture is loaded upside down and backwards by default so lets flip it\n          uv.y = 1.0 - uv.y;\n          \n          vec4 maskT = texture2D(texMask, uv);\n          vec4 imgT = texture2D(texImg, uv);\n          \n          float gray = (maskT.r + maskT.g + maskT.b) / 3.0;\n        \n          // mask\n          float threshR = imgT.r* gray ;\n          float threshG = imgT.g* gray ;\n          float threshB = imgT.b* gray ;\n          vec3 thresh = vec3(threshR, threshG, threshB);\n        \n          // render the output\n          gl_FragColor = vec4(thresh, gray);\n        }";
      var vert = "// vert file and comments from adam ferriss\n        // https://github.com/aferriss/p5jsShaderExamples\n        \n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        // our vertex data\n        attribute vec3 aPosition;\n        attribute vec2 aTexCoord;\n        \n        // lets get texcoords just for fun! \n        varying vec2 vTexCoord;\n        \n        void main() {\n          // copy the texcoords\n          vTexCoord = aTexCoord;\n        \n          // copy the position data into a vec4, using 1.0 as the w component\n          vec4 positionVec4 = vec4(aPosition, 1.0);\n          positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n        \n          // send the vertex information on to the fragment shader\n          gl_Position = positionVec4;\n        }";
      this.bezShader = this.bufferWEBGL.createShader(vert, frag);
      this.bezierShaderLoaded = true;
    } ////////////////////////////////////////
    // SURFACES
    ////////////////////////////////////////

    /**
     * Creates and registers a new quad surface.
     *
     * @param w width
     * @param h height
     * @param res resolution (number of tiles per axis)
     * @return
     */

  }, {
    key: "createQuadMap",
    value: function createQuadMap(w, h) {
      var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;
      var s = new surfaces_QuadMap(this.surfaces.length, w, h, res, this.buffer, this.pInst);
      this.surfaces.push(s);
      return s;
    }
    /**
     * Creates and registers a new triangle surface.
     *
     * @param w width
     * @param h height
     * @param res resolution (number of tiles per axis)
     * @return
     */

  }, {
    key: "createTriMap",
    value: function createTriMap(w, h) {
      var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;
      var s = new surfaces_TriMap(this.surfaces.length, w, h, res, this.buffer, this.pInst);
      this.surfaces.push(s);
      return s;
    }
  }, {
    key: "createLineMap",
    value: function createLineMap() {
      var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (x0 == 0 && y0 == 0 && x1 == 0 && y1 == 0) {
        x1 = 200;
        y0 = 30 * this.lines.length;
        y1 = 30 * this.lines.length;
      }

      var l = new lines_LineMap(x0, y0, x1, y1, this.lines.length, this.pInst);
      this.lines.push(l);
      return l;
    }
  }, {
    key: "createPolyMap",
    value: function createPolyMap() {
      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
      if (numPoints < 3) numPoints = 3;
      var s = new surfaces_PolyMap(this.surfaces.length, numPoints, this.buffer, this.pInst);
      this.surfaces.push(s);
      return s;
    }
  }, {
    key: "createBezierMap",
    value: function createBezierMap() {
      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      // why was it calling this twice??
      var bez = new Bezier_BezierMap(this.surfaces.length, numPoints, this, this.pInst);
      this.surfaces.push(bez);
      return bez;
    } ////////////////////////////////////////
    // INTERACTION
    ////////////////////////////////////////

  }, {
    key: "onClick",
    value: function onClick() {
      // ignore input events if the calibrate flag is not set
      if (!this.calibrate) return;

      if (this.moveMode == "SURFACES") {
        this.checkSurfacesClick();
      } else if (this.moveMode == "POINTS") {
        this.checkPointsClick();
      } else {
        if (!this.checkPointsClick()) {
          this.checkSurfacesClick();
        }
      }
    }
  }, {
    key: "moveSurfaces",
    value: function moveSurfaces() {
      this.moveMode = "SURFACES";
    }
  }, {
    key: "moveControlPoints",
    value: function moveControlPoints() {
      this.moveMode = "POINTS";
    }
  }, {
    key: "moveAll",
    value: function moveAll() {
      this.moveMode = "ALL";
    }
  }, {
    key: "isMovingPoints",
    value: function isMovingPoints() {
      return this.moveMode == "ALL" || this.moveMode == "POINTS";
    }
  }, {
    key: "checkSurfacesClick",
    value: function checkSurfacesClick() {
      // Check Lines
      // navigate the list backwards, as to select
      for (var i = this.lines.length - 1; i >= 0; i--) {
        var s = this.lines[i];
        this.dragged = s.selectSurface();

        if (this.dragged != null) {
          return true;
        }
      } // check mapping surfaces


      for (var _i = this.surfaces.length - 1; _i >= 0; _i--) {
        var _s = this.surfaces[_i];
        this.dragged = _s.selectSurface();

        if (this.dragged != null) {
          this.selected = _s;
          return true;
        }
      }

      this.selected = null;
      return false;
    }
  }, {
    key: "checkPointsClick",
    value: function checkPointsClick() {
      // Check Lines
      // navigate the list backwards, as to select
      for (var i = this.lines.length - 1; i >= 0; i--) {
        var s = this.lines[i];
        this.dragged = s.selectPoints();

        if (this.dragged != null) {
          return true;
        }
      } // TODO - check bez control points before anchors
      // check mapping surfaces


      for (var _i2 = this.surfaces.length - 1; _i2 >= 0; _i2--) {
        var _s2 = this.surfaces[_i2];
        this.dragged = _s2.selectPoints();

        if (this.dragged != null) {
          this.selected = _s2;
          return true;
        }
      }

      this.selected = null;
      return false;
    }
  }, {
    key: "checkSelectedClick",
    value: function checkSelectedClick() {
      // first check masks
      if (this.selected) {
        this.dragged = this.selected.selectPoints();
        if (this.dragged) return true;
        return false;
      }

      return false;
    }
  }, {
    key: "onDrag",
    value: function onDrag() {
      if (this.dragged != null) this.dragged.moveTo();
    }
  }, {
    key: "onRelease",
    value: function onRelease() {
      this.dragged = null;
    }
  }, {
    key: "isDragging",
    value: function isDragging(surface) {
      // TODO - ??? why return true?
      // need to remember what I was doing here
      if (this.dragged === null) return true;
      return this.dragged === surface;
    }
  }, {
    key: "updateEvents",
    value: function updateEvents() {
      if (this.pInst.mouseIsPressed) {
        if (!this.pMousePressed) {
          this.onClick();
        } else {
          this.onDrag();
        }
      } else {
        if (this.pMousePressed) {
          this.onRelease();
        }
      }

      this.pMousePressed = this.pInst.mouseIsPressed;
    } ////////////////////////////////////////
    // LOADING / SAVING
    ////////////////////////////////////////

  }, {
    key: "load",
    value: function load() {
      var filepath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "maps/map.json";
      console.log("loading json file: ".concat(filepath));
      var mainThis = this;

      var error = function error(err) {
        return console.log("error loading ".concat(filepath), err);
      };

      this.pInst.loadJSON("".concat(filepath), mainThis.loadedJson.bind(mainThis), error);
    }
  }, {
    key: "loadedJson",
    value: function loadedJson(json) {
      if (json.surfaces) this.loadSurfaces(json);
      if (json.lines) this.loadLines(json);
    }
  }, {
    key: "loadSurfaces",
    value: function loadSurfaces(json) {
      var jSurfaces = json.surfaces;

      if (jSurfaces.length !== this.surfaces.length) {
        console.warn("json calibration file has ".concat(jSurfaces.length, " surface maps but there are ").concat(this.surfaces.length, " surface maps in memory (check sketch.js for # of map objects)"));
      } // TODO - don't remember what I was doing here...
      // in the future if we want to make sure only to load tris into tris, etc.


      var jTriSurfaces = jSurfaces.filter(function (surf) {
        return surf.type === "TRI";
      });
      var jQuadSurfaces = jSurfaces.filter(function (surf) {
        return surf.type === "QUAD";
      });
      var jBezSurfaces = jSurfaces.filter(function (surf) {
        return surf.type === "BEZ";
      });
      var jPolySurfaces = jSurfaces.filter(function (surf) {
        return surf.type === "POLY";
      });
      var mapTris = this.surfaces.filter(function (surf) {
        return surf.type === "TRI";
      });
      var mapQuads = this.surfaces.filter(function (surf) {
        return surf.type === "QUAD";
      });
      var mapBez = this.surfaces.filter(function (surf) {
        return surf.type === "BEZ";
      });
      var mapPolys = this.surfaces.filter(function (surf) {
        return surf.type === "POLY";
      }); // loading tris

      var index = 0;

      while (index < jTriSurfaces.length && index < mapTris.length) {
        var s = mapTris[index];
        if (s.isEqual(mapTris[index])) s.load(jTriSurfaces[index]);else console.warn("mismatch between calibration surface types / ids");
        index++;
      } // loading quads


      index = 0;

      while (index < jQuadSurfaces.length && index < mapQuads.length) {
        var _s3 = mapQuads[index];
        if (_s3.isEqual(mapQuads[index])) _s3.load(jQuadSurfaces[index]);else console.warn("mismatch between calibration surface types / ids");
        index++;
      } // loading bez


      index = 0;

      while (index < jBezSurfaces.length && index < mapBez.length) {
        var _s4 = mapBez[index];

        if (_s4.isEqual(mapBez[index])) {
          _s4.load(jBezSurfaces[index]);
        } else console.warn("mismatch between calibration bez surface types / ids");

        index++;
      } // loading poly


      index = 0;

      while (index < jPolySurfaces.length && index < mapPolys.length) {
        var _s5 = mapPolys[index];

        if (_s5.isEqual(mapPolys[index])) {
          _s5.load(jPolySurfaces[index]);
        } else console.warn("mismatch between calibration poly surface types / ids");

        index++;
      }
    }
  }, {
    key: "loadLines",
    value: function loadLines(json) {
      var jLines = json.lines;

      if (jLines.length !== this.lines.length) {
        console.warn("json calibration file has ".concat(jLines.length, " line maps but there are ").concat(this.lines.length, " line maps in memory"));
      }

      var index = 0;

      while (index < jLines.length && index < this.lines.length) {
        this.lines[index].load(jLines[index]);
        index++;
      }
    }
  }, {
    key: "save",
    value: function save() {
      var filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "map.json";
      console.log("saving all mapped surfaces to json...");
      var json = {
        surfaces: [],
        lines: []
      }; // for (const mask of this.masks) {
      //     json.masks.push(mask.getJson());
      // }

      var _iterator = ProjectionMapper_createForOfIteratorHelper(this.surfaces),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var surface = _step.value;
          json.surfaces.push(surface.getJson());
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = ProjectionMapper_createForOfIteratorHelper(this.lines),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var line = _step2.value;
          json.lines.push(line.getJson());
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.pInst.saveJSON(json, "".concat(filename));
    } ////////////////////////////////////////
    // CALIBRATING
    ////////////////////////////////////////

  }, {
    key: "startCalibration",
    value: function startCalibration() {
      this.calibrate = true;
    }
  }, {
    key: "stopCalibration",
    value: function stopCalibration() {
      this.calibrate = false;
    }
  }, {
    key: "toggleCalibration",
    value: function toggleCalibration() {
      this.calibrate = !this.calibrate;
    } ////////////////////////////////////////
    // RENDERING
    ////////////////////////////////////////

    /**
     * begins drawing surfaces
     *
     * @deprecated since v0.0.1
     */

  }, {
    key: "beginSurfaces",
    value: function beginSurfaces() {
      console.warn("beginSurfaces() is a deprecated method");
    }
    /**
     * ends drawing surfaces
     *
     * @deprecated since v0.0.1
     */

  }, {
    key: "endSurfaces",
    value: function endSurfaces() {
      console.warn("endSurfaces() is a deprecated method");
    }
    /**
     * renders surfaces
     *
     * @deprecated since v0.0.1
     */

  }, {
    key: "renderSurfaces",
    value: function renderSurfaces() {
      console.warn("renderSurfaces() is a deprecated method");
    }
    /**
     * displays surfaces
     *
     * @deprecated since v0.0.1
     */

  }, {
    key: "display",
    value: function display() {
      // if (this.selected) {
      //     this.selected.displaySelected();
      // }
      console.warn("display() is a deprecated method");
    }
  }, {
    key: "displayControlPoints",
    value: function displayControlPoints() {
      if (this.calibrate) {
        // for (const mask of this.masks) {
        //     mask.displayControlPoints();
        // }
        var _iterator3 = ProjectionMapper_createForOfIteratorHelper(this.surfaces),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var surface = _step3.value;
            surface.displayControlPoints();
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        var _iterator4 = ProjectionMapper_createForOfIteratorHelper(this.lines),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var lineMap = _step4.value;
            lineMap.displayCalibration();
            lineMap.displayControlPoints();
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }
  }, {
    key: "getOscillator",
    value: function getOscillator(seconds) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return getPercentWave(this.pInst, seconds, offset);
    }
  }]);

  return ProjectionMapper;
}();

var pMapper = new ProjectionMapper();
/**
 * Initializes the projection mapper object
 *
 * @param {p5} pInst is the p5 object - useful for instance mode (??)
 * @param {number} w is the width of the buffer graphics object used to draw textures on mapped surfaces
 * @param {number} h is the height of the buffer graphics object...
 */

p5.prototype.createProjectionMapper = function (pInst, w, h) {
  if (!w) w = pInst.width;
  if (!h) h = pInst.height;
  pMapper.pInst = pInst;
  pMapper.init(w, h);
  return pMapper;
};

p5.prototype.isCalibratingMapper = function () {
  return pMapper.calibrate;
};

p5.prototype.isMovingPoints = function () {
  return pMapper.isMovingPoints();
};

p5.prototype.isDragging = function (surface) {
  return pMapper.isDragging(surface);
};

p5.prototype.initPMapperShader = function () {
  // TODO - is there a better way to do this?
  // const filePath = "../../src/surfaces/Bezier/shader";
  // const filePath = "https://cdn.jsdelivr.net/gh/jdeboi/p5.mapper/src/surfaces/Bezier/shader"
  var filePath = "https://cdn.statically.io/gh/jdeboi/p5.mapper/main/src/surfaces/Bezier/shader";
  this.loadShader(filePath + ".vert", filePath + ".frag", function (bezShader) {
    return pMapper.preload(bezShader);
  });
}; // p5.prototype.registerMethod('init', p5.prototype.initPMapperShader);
// p5.prototype.registerMethod('pre', () => pMapper.beginSurfaces());


p5.prototype.registerMethod("post", function () {
  return pMapper.displayControlPoints();
});
p5.prototype.registerMethod("post", function () {
  return pMapper.updateEvents();
});
/* harmony default export */ const src_ProjectionMapper = ((/* unused pure expression or super */ null && (pMapper)));
;// CONCATENATED MODULE: ./src/index.js

/******/ 	return __webpack_exports__;
/******/ })()
;
});